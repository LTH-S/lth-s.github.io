<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL主从同步</title>
    <link href="/2022/05/09/MySQL%208.0%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    <url>/2022/05/09/MySQL%208.0%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL主从同步"><a href="#MySQL主从同步" class="headerlink" title="MySQL主从同步"></a>MySQL主从同步</h2><h3 id="我的配置：MySQL-8-0，Centos-7（主机），Windows-10（从机）"><a href="#我的配置：MySQL-8-0，Centos-7（主机），Windows-10（从机）" class="headerlink" title="我的配置：MySQL 8.0，Centos 7（主机），Windows 10（从机）"></a>我的配置：MySQL 8.0，Centos 7（主机），Windows 10（从机）</h3><h3 id="第一步：查看binlog是否开启"><a href="#第一步：查看binlog是否开启" class="headerlink" title="第一步：查看binlog是否开启"></a>第一步：查看binlog是否开启</h3><p>MySQL8.0开始，默认开启binlog，如果是5.7的版本，也可以在my.cnf&#x2F;my.ini中进行配置开启。</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h4><p><img src="https://img-blog.csdnimg.cn/fb7bb2c988cd4cfdb2c8b6423257992b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_19,color_FFFFFF,t_70,g_se,x_16"> </p><h4 id="从机"><a href="#从机" class="headerlink" title="从机"></a>从机</h4><p><img src="https://img-blog.csdnimg.cn/ed46a0b2d9b948658ff779236c25adcb.png">    </p><h3 id="第二步：设置配置文件"><a href="#第二步：设置配置文件" class="headerlink" title="第二步：设置配置文件"></a>第二步：设置配置文件</h3><h4 id="主机-1"><a href="#主机-1" class="headerlink" title="主机"></a>主机</h4><p>Linux下的MySQL的配置文件默认在&#x2F;etc&#x2F;my.cnf，使用vim命令进行编辑</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/my</span>.cnf<br></code></pre></td></tr></table></figure><p>在[mysqld]下配置信息，注意是[mysqld]下，如果配置到其他地方会导致读取不到。</p><p><img src="https://img-blog.csdnimg.cn/e6336420d100498a82e1880522c78b27.png" alt=" ">    </p><p>这里的binlog-do-db可以不配置，根据需求来。</p><h4 id="从机-1"><a href="#从机-1" class="headerlink" title="从机"></a>从机</h4><p>Windows下的MySQL配置文件默认在C:\Program Files\MySQL下，打开my.ini进行编辑</p><p>同样，在[mysqld]下配置信息</p><p><img src="https://img-blog.csdnimg.cn/f3672a7f87c44764a78de7dba128dbf5.png">    </p><h3 id="第三步：重启服务"><a href="#第三步：重启服务" class="headerlink" title="第三步：重启服务"></a>第三步：重启服务</h3><h4 id="主机-2"><a href="#主机-2" class="headerlink" title="主机"></a>主机</h4><p>Linux下MySQL重启命令</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">systemctl <span class="hljs-built_in">restart</span> mysqld.service<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b710c2a6392340c4acb1171d7ac32d51.png">    </p><h4 id="从机-2"><a href="#从机-2" class="headerlink" title="从机"></a>从机</h4><p>打开cmd先输入net stop mysql，然后再输入net start mysql</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> stop mysql<br><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> mysql<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/dfbcd6d95d7341c39c942c54ea08f38b.png">    </p><h3 id="第四步：设置账号"><a href="#第四步：设置账号" class="headerlink" title="第四步：设置账号"></a>第四步：设置账号</h3><h4 id="主机-3"><a href="#主机-3" class="headerlink" title="主机"></a>主机</h4><p>通常，主从同步业务场景，是给予从库一个账号，正常是不会给予root账号的，这里我先使用我之前创建的账号zhku进行演示（你也可以使用root账号，但不建议）。</p><p>先查看该账户是否具有主从同步的权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Repl_slave_priv, Repl_client_priv <span class="hljs-keyword">from</span> mysql.user <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;zhku&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/1aaea14311e34643aaf21d85604acbff.png">    </p><p>显示没有赋予该权限</p><p>赋予权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> replication slave, replication client <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;zhku&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="第五步：查看状态"><a href="#第五步：查看状态" class="headerlink" title="第五步：查看状态"></a>第五步：查看状态</h3><h4 id="主机-4"><a href="#主机-4" class="headerlink" title="主机"></a>主机</h4><h5 id="查看master状态"><a href="#查看master状态" class="headerlink" title="查看master状态"></a>查看master状态</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> master status;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/52956461efe4460ba24d366a683f2547.png">    </p><p>file：表示同步的bin-log信息从哪个文件开始；</p><p>position：表示从file的哪个位置开始；</p><p>binlog_do_db：表示同步哪一个库(如果在配置文件中没有设置，则是空)</p><h4 id="从机-3"><a href="#从机-3" class="headerlink" title="从机"></a>从机</h4><h5 id="在从机上设置主服务器IP地址"><a href="#在从机上设置主服务器IP地址" class="headerlink" title="在从机上设置主服务器IP地址"></a>在从机上设置主服务器IP地址</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">change master <span class="hljs-keyword">to</span> master_host<span class="hljs-operator">=</span><span class="hljs-string">&#x27;120.***.***.110&#x27;</span>,master_port<span class="hljs-operator">=</span><span class="hljs-number">3306</span>,master_user<span class="hljs-operator">=</span><span class="hljs-string">&#x27;zhku&#x27;</span>,master_password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;123456&#x27;</span>,master_log_file<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mysql-bin.000001&#x27;</span>,master_log_pos<span class="hljs-operator">=</span><span class="hljs-number">156</span>;<br></code></pre></td></tr></table></figure><p>这里设置master_host为主机的IP地址，master_user为登录用户，如zhku，设置master_password为密码，这里我的密码是123456，master_log_file为主机上查看master status的file，master_log_pos为主机上查看到的position。</p><h5 id="开启slave"><a href="#开启slave" class="headerlink" title="开启slave"></a>开启slave</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> slave;<br></code></pre></td></tr></table></figure><h5 id="查询slave状态"><a href="#查询slave状态" class="headerlink" title="查询slave状态"></a>查询slave状态</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> slave status;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/24b3cecfa3b74baa8460fdb7c2ca7a08.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_15,color_FFFFFF,t_70,g_se,x_16"></p><p>结果太多，我这里以列显示好看一点。</p><p>可以看到最关键的两个参数，倒数两个，Slave_IO_Running和Slave_SQL_Running，显示Yes则代表成功实现主从同步，第一个Slave_IO_State也显示正在等待主机发送事件信息。</p><h4 id="到此为止就配置成功了！"><a href="#到此为止就配置成功了！" class="headerlink" title="到此为止就配置成功了！"></a>到此为止就配置成功了！</h4><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="第一个问题：在第三步重启服务时启动失败"><a href="#第一个问题：在第三步重启服务时启动失败" class="headerlink" title="第一个问题：在第三步重启服务时启动失败"></a>第一个问题：在第三步重启服务时启动失败</h4><p>原因是配置文件有问题，需要检查配置文件是否配置正确，如单词拼写，数据库是否存在等。</p><h4 id="第二个问题：在第五步时从机查看slave-status时，Slave-IO-Running显示Connecting"><a href="#第二个问题：在第五步时从机查看slave-status时，Slave-IO-Running显示Connecting" class="headerlink" title="第二个问题：在第五步时从机查看slave status时，Slave_IO_Running显示Connecting"></a>第二个问题：在第五步时从机查看slave status时，Slave_IO_Running显示Connecting</h4><p><img src="https://img-blog.csdnimg.cn/42ec408a8aab455b8c7608b36d197999.png">    </p><p>原因：可以继续查看后面的列，找到Last_IO_Error列</p><p><img src="https://img-blog.csdnimg.cn/2a88ca0f134b4ff8b10bc62d626b22ce.png">    </p><p>查看里面的报错显示的是Authentication plugin ‘caching_sha2_password’ reported error: Authentication requires secure connection.。</p><p><img src="https://img-blog.csdnimg.cn/3de2bbb2f9894f3ea1827e41bd69f0dc.png">    </p><p>前往主机查询</p><p><img src="https://img-blog.csdnimg.cn/cf4fa2323eab4239916991ee2547c50c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_18,color_FFFFFF,t_70,g_se,x_16"></p><p>发现zhku账号与root账号的plugin值不同，需要将zhku账号的plugin值修改为mysql_native_password（使用update语句，这里不再赘述），修改后即可成功显示两个YES。</p><p>这里也有可能报错信息不是这个问题，该列显示connecting的问题主要有三个，一个是网络问题，一个是账号密码不对，一个是master_log_file和master_log_pos设置不对。网络问题的话可以检查防火墙是否开启，笔者这里使用的是阿里云服务器，服务器上打开了安全组，Centos上打开了防火墙端口，所以可以访问，如果是虚拟机则要看桥接模式等，这里不再赘述。</p><p>Linux上打开，关闭，查看防火墙的博文链接：</p><p><a href="https://blog.csdn.net/weixin_45930241/article/details/123219592">https://blog.csdn.net/weixin_45930241&#x2F;article&#x2F;details&#x2F;123219592</a></p><h4 id="第三个问题：在第五步时从机查看slave-status时，Slave-IO-Running显示No"><a href="#第三个问题：在第五步时从机查看slave-status时，Slave-IO-Running显示No" class="headerlink" title="第三个问题：在第五步时从机查看slave status时，Slave_IO_Running显示No"></a>第三个问题：在第五步时从机查看slave status时，Slave_IO_Running显示No</h4><p><img src="https://img-blog.csdnimg.cn/c185f1273f9e441d9d94046f59b68fb0.png">    </p><p>同第二个问题，查询后面的信息列，看看报错原因是什么</p><p><img src="https://img-blog.csdnimg.cn/566e3b566d804eecb4c5059e91cc42ad.png">    </p><p>发现显示文件名字不一致</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> master status;<br></code></pre></td></tr></table></figure><p>在从机上使用show master status命令查看</p><p><img src="https://img-blog.csdnimg.cn/e7b70bebadfa48cd83ec1b790eebd534.png">    </p><p>在主机上使用show master status命令查看</p><p><img src="https://img-blog.csdnimg.cn/5a700da7c9154344a86ebae7e07e4814.png">    </p><p>比对发现，File和Position不一致。</p><p>使用stop slave命令停掉从机的slave，回到第五步，重新使用change master命令设置，最后再start slave即可，如果还不行，就再去检查两个机器的配置文件是否修改正确。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">stop slave;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git --reset hard命令回退版本后恢复</title>
    <link href="/2022/04/03/git%20--reset%20hard%E5%91%BD%E4%BB%A4%E5%9B%9E%E9%80%80%E7%89%88%E6%9C%AC%E5%90%8E%E6%81%A2%E5%A4%8D/"/>
    <url>/2022/04/03/git%20--reset%20hard%E5%91%BD%E4%BB%A4%E5%9B%9E%E9%80%80%E7%89%88%E6%9C%AC%E5%90%8E%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<p>本来想切换分支的，脑子糊涂选了回退版本，本来git commit是这样的。<br><img src="https://img-blog.csdnimg.cn/876887c190e641aa8965036cec53456e.png"><br>git reset后，最新的版本不见了。<br><img src="https://img-blog.csdnimg.cn/5c3fe47a52b445d5a22f7de68a3f1e66.png"><br>恢复方法：<br>git reflog可以查询到所有对git的操作。<br><img src="https://img-blog.csdnimg.cn/2f59672b047c4d64ae3be8234269a115.png"><br>可以发现我在最新的一次操作，使用了reset命令。<br>现在来恢复<br>仍然是使用git –reset hard命令<br><img src="https://img-blog.csdnimg.cn/8b4d843f5b0a4b0e9439b2b7269dc9a5.png"><br>再次查看，发现恢复成功了，泪目</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础篇之查找与排序</title>
    <link href="/2022/03/29/Java%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/29/Java%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-二分查找-⭐"><a href="#1-二分查找-⭐" class="headerlink" title="1. 二分查找(⭐)"></a>1. 二分查找(⭐)</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>能够用自己语言<strong>描述二分查找算法</strong></li><li>能够<strong>手写</strong>二分查找代码</li><li>能够解答一些变化后的考法</li></ul><h3 id="二分查找代码算法思路"><a href="#二分查找代码算法思路" class="headerlink" title="二分查找代码算法思路"></a>二分查找代码算法思路</h3><ol><li><p>前提：有已排序数组 A（假设已经做好）</p></li><li><p>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</p></li><li><p>获取中间索引 M &#x3D; (L+R) &#x2F;2</p></li><li><p>中间索引的值  A[M] 与待搜索的值 T 进行比较</p><p>① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引</p><p>② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p><p>③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p></li><li><p>当 L &gt; R 时，表示没有找到，应结束循环</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面这个算法是基于Arrays.binarySearch实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearch</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>        Arrays.sort(a);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> binarySearch(a, <span class="hljs-number">7</span>);<br>        System.out.println(index);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = a.length - <span class="hljs-number">1</span>, mid;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-comment">// 等价于(l+r)/2，但是如果r是Integer.MAX_VALUE的话，可能会导致溢出。</span><br>            mid = (l + r) &gt;&gt;&gt; <span class="hljs-number">1</span>; <br>            <span class="hljs-comment">// a[mid]与target相同</span><br>            <span class="hljs-keyword">if</span> (a[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-comment">// a[mid]比target大，说明在左边</span><br>            <span class="hljs-keyword">if</span> (a[mid] &gt; target) &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// a[mid]比target小，说明在右边</span><br>            <span class="hljs-keyword">if</span> (a[mid] &lt; target) &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择题考法"><a href="#选择题考法" class="headerlink" title="选择题考法"></a>选择题考法</h3><p><strong>口诀：奇数二分取中间，偶数二分取中间靠左</strong></p><ol><li><p>有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数 </p></li><li><p>使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较</p></li><li><p>在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次</p></li></ol><p>对于前两个题目，记得一个简要判断口诀：<strong>奇数二分取中间，偶数二分取中间靠左</strong>。对于后一道题目，需要知道公式：<strong>n &#x3D; log2^N</strong> 所以说，128个元素需要7次，其中 n 为查找次数，N 为元素个数</p><h2 id="2-冒泡排序-⭐"><a href="#2-冒泡排序-⭐" class="headerlink" title="2. 冒泡排序(⭐)"></a>2. 冒泡排序(⭐)</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ul><li>能够用自己语言<strong>描述冒泡排序算法</strong></li><li>能够<strong>手写</strong>冒泡排序代码</li><li>了解一些冒泡排序的<strong>优化手段</strong></li></ul><h3 id="冒泡排序算法思路"><a href="#冒泡排序算法思路" class="headerlink" title="冒泡排序算法思路"></a>冒泡排序算法思路</h3><ol><li>依次比较数组中相邻两个元素大小，若 a[j] &gt; a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后</li><li>重复以上步骤，直到整个数组有序</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>        bubbleSort(a);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>        <span class="hljs-comment">// 循环次数只用循环a.length-1次，比如说8个元素，只用循环7次即可排序完成。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; a.length - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-comment">// 记录是否进行交换，如果没不再交换了就直接退出循环。</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 只用比较a.length-1-j次，因为有j个数已经排好了，没必要进行比较了。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length - <span class="hljs-number">1</span> - j; i++) &#123;<br>                <span class="hljs-keyword">if</span> (a[i] &gt; a[i + <span class="hljs-number">1</span>]) &#123;<br>                    swap(a, i, i + <span class="hljs-number">1</span>);<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果这一遍循环没有进行交换，则说明数组已经排序好了，则直接退出循环。</span><br>            <span class="hljs-keyword">if</span> (!flag) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(Arrays.toString(a));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优化点1：每经过一轮冒泡，内层循环就可以减少一次（<strong>通过内层循环条件 -j 来实现</strong>）</li><li>优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环（<strong>设置标记变量来实现</strong>）</li></ul><p><strong>进一步优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble_v2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示最后一次交换索引位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;比较次数&quot;</span> + i);<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[i + <span class="hljs-number">1</span>]) &#123;<br>                Utils.swap(a, i, i + <span class="hljs-number">1</span>);<br>                last = i;<br>            &#125;<br>        &#125;<br>        n = last;<br>        System.out.println(<span class="hljs-string">&quot;第轮冒泡&quot;</span><br>                           + Arrays.toString(a));<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为零，表示整个数组有序，直接退出外层循环即可</li></ul><h2 id="3-选择排序-不稳定"><a href="#3-选择排序-不稳定" class="headerlink" title="3. 选择排序(不稳定)"></a>3. 选择排序(不稳定)</h2><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><ul><li>能够用自己语言<strong>描述选择排序算法</strong></li><li>能够<strong>比较选择排序与冒泡排序</strong></li><li>理解<strong>非稳定排序与稳定排序</strong></li></ul><h3 id="选择排序算法思路"><a href="#选择排序算法思路" class="headerlink" title="选择排序算法思路"></a>选择排序算法思路</h3><ol><li><p>将数组分为两个子集，已排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集</p></li><li><p>重复以上步骤，直到整个数组有序</p></li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectionSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>        selectionSort(a);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>        <span class="hljs-comment">// 只用循环a.length-1次，比如说8个元素，只用循环7次即可排序完成。</span><br>        <span class="hljs-comment">// i变量代表着每轮选择的最小元素要放到的索引位置。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">// 每轮循环找到的最小元素，初始值从i开始</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-comment">// 从当前元素开始，与后面所有元素进行比较，选出最小的元素。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">1</span>; j &lt; a.length; j++) &#123;<br>                <span class="hljs-comment">// 如果遍历到某个元素比a[num]小，则将该元素下标赋值给num</span><br>                <span class="hljs-keyword">if</span> (a[num] &gt; a[j]) &#123;<br>                    num = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (num != i) &#123;<br>                <span class="hljs-comment">// 将这次循环找到的最小的元素放入i位置。</span><br>                swap(a, num, i);<br>            &#125;<br>            System.out.println(Arrays.toString(a));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优化点：为减少交换次数，每一轮可以<strong>先找最小的索引</strong>，在每轮<strong>最后再交换</strong>元素</li></ul><h3 id="冒泡排序-vs-选择排序"><a href="#冒泡排序-vs-选择排序" class="headerlink" title="冒泡排序 vs 选择排序"></a>冒泡排序 vs 选择排序</h3><ol><li>二者平均<strong>时间复杂度</strong>都是 O(n^2)</li><li>选择排序一般要快于冒泡，因为其交换次数少(记录下标形式)      <strong>插入 &gt; 选择 &gt; 冒泡</strong></li><li>但<strong>如果集合有序度高，冒泡优于选择</strong></li></ol><h2 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h2><h3 id="要求-3"><a href="#要求-3" class="headerlink" title="要求"></a>要求</h3><ul><li>能够用自己语言描述插入排序算法</li><li>能够<strong>比较插入排序与选择排序</strong></li></ul><h3 id="插入排序算法思路"><a href="#插入排序算法思路" class="headerlink" title="插入排序算法思路"></a>插入排序算法思路</h3><ol><li><p>将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）</p></li><li><p>重复以上步骤，直到整个数组有序</p></li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>        insertSort(a);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>        <span class="hljs-comment">// i代表待插入元素的索引，从第二个元素开始，也就是下标为1的元素开始遍历。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;<br>            <span class="hljs-comment">// 代表待插入的元素值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> a[i];<br>            <span class="hljs-comment">// sortedIndex代表已经排好序的元素末尾索引，初始值为i-1</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">sortedIndex</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (; sortedIndex &gt;= <span class="hljs-number">0</span>; sortedIndex--) &#123;<br>                <span class="hljs-comment">// 将新元素与前面的元素一个个比较，如果小于前面的元素</span><br>                <span class="hljs-keyword">if</span> (target &lt; a[sortedIndex]) &#123;<br>                    <span class="hljs-comment">// 前面的元素就往后移一位。</span><br>                    a[sortedIndex + <span class="hljs-number">1</span>] = a[sortedIndex];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 退出循环，减少比较次数。</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            a[sortedIndex + <span class="hljs-number">1</span>] = target;<br>            System.out.println(Arrays.toString(a));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序-vs-选择排序"><a href="#插入排序-vs-选择排序" class="headerlink" title="插入排序 vs 选择排序"></a>插入排序 vs 选择排序</h3><ol><li>二者平均<strong>时间复杂度</strong>都是 O(n^2)</li><li>大部分时间，插入都略优于选择。  <strong>插入 &gt; 选择 &gt; 冒泡</strong></li><li><strong>有序集合</strong>的插入时间复杂度为O(n)</li></ol><p><strong>优点</strong>：小数据量排序，都会优先选择插入排序</p><h2 id="5-希尔排序-不稳定"><a href="#5-希尔排序-不稳定" class="headerlink" title="5. 希尔排序(不稳定)"></a>5. 希尔排序(不稳定)</h2><h3 id="要求-4"><a href="#要求-4" class="headerlink" title="要求"></a>要求</h3><ul><li>能够用自己语言<strong>描述希尔排序算法</strong></li></ul><h3 id="希尔排序算法思路"><a href="#希尔排序算法思路" class="headerlink" title="希尔排序算法思路"></a>希尔排序算法思路</h3><ol><li><p>首先<strong>选取一个间隙序列</strong>，如 **(n&#x2F;2，n&#x2F;4 … 1)**，n 为数组长度</p></li><li><p>每一轮将间隙相等的元素视为一组，对组内元素进行插入排序，目的有二</p><p>① 少量元素插入排序速度很快</p><p>② <strong>让组内值较大的元素更快地移动到后方</strong></p></li><li><p><strong>当间隙逐渐减少，直至为 1 时，即可完成排序</strong></p></li></ol><h2 id="6-快速排序-不稳定⭐"><a href="#6-快速排序-不稳定⭐" class="headerlink" title="6. 快速排序(不稳定⭐)"></a>6. 快速排序(不稳定⭐)</h2><h3 id="要求-5"><a href="#要求-5" class="headerlink" title="要求"></a>要求</h3><ul><li>能够<strong>用自己语言描述快速排序算法</strong></li><li>掌握<strong>手写</strong>单边循环、双边循环代码之一</li><li>能够<strong>说明快排特点</strong></li><li>了解<strong>洛穆托</strong>与<strong>霍尔</strong>两种分区方案的性能比较</li></ul><h3 id="快速排序算法思路（总）"><a href="#快速排序算法思路（总）" class="headerlink" title="快速排序算法思路（总）"></a>快速排序算法思路（总）</h3><ol><li><ol><li><strong>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</strong></li><li>当分区完成时，<strong>基准点元素的位置就是其最终位置</strong></li></ol></li><li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 </li><li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li></ol><h3 id="单边循环快排（lomuto-洛穆托分区方案）"><a href="#单边循环快排（lomuto-洛穆托分区方案）" class="headerlink" title="单边循环快排（lomuto 洛穆托分区方案）"></a>单边循环快排（lomuto 洛穆托分区方案）</h3><ol><li><p>选择<strong>最右元素</strong>作为基准点元素</p></li><li><p><strong>j 指针负责找到比基准点小的元素</strong>，一旦找到则与 i 进行交换</p></li><li><p><strong>i 指针维护小于基准点元素的边界</strong>，也是每次交换的目标索引</p></li><li><p>最后基准点与 i 交换，i 即为分区位置</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>        quickSort(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>        System.out.println(Arrays.toString(a));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-comment">// 如果区间内没有元素，则直接return</span><br>        <span class="hljs-keyword">if</span> (low &gt;= high) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// p是基准的索引值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(a, low, high);<br>        <span class="hljs-comment">// 左边分区的递归</span><br>        quickSort(a, low, p - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 右边分区的递归</span><br>        quickSort(a, p + <span class="hljs-number">1</span>, high);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> low  数组的左边界</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> high 数组的右边界</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-comment">// pivot是基准点元素，这里选择数组最右边的元素作为基准点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> a[high];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low; j &lt; high; j++) &#123;<br>            <span class="hljs-comment">// 如果当前元素小于pivot，就让i与j互换</span><br>            <span class="hljs-keyword">if</span> (a[j] &lt; pivot) &#123;<br>                swap(a, i, j);<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 交换i与pivot，让基准点左边全是小于pivot的，右边全是大于pivot的。</span><br>        swap(a, high, i);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双边循环快排（不完全等价于-hoare-霍尔分区方案）"><a href="#双边循环快排（不完全等价于-hoare-霍尔分区方案）" class="headerlink" title="双边循环快排（不完全等价于 hoare 霍尔分区方案）"></a>双边循环快排（不完全等价于 hoare 霍尔分区方案）</h3><ol><li>选择<strong>最左元素</strong>作为基准点元素</li><li><strong>j 指针负责从右向左找比基准点小的元素</strong></li><li><strong>i 指针负责从左向右找比基准点大的元素</strong>，一旦找到二者交换，直至 i，j 相交</li><li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li></ol><p><strong>要点</strong></p><ol><li>基准点在左边，并且要<strong>先 j 后 i</strong></li><li>while( <strong>i</strong> **&lt; j** &amp;&amp; a[j] &gt; pivot ) j– </li><li>while ( <strong>i</strong> <strong>&lt; j</strong> &amp;&amp; a[i] &lt;&#x3D; pivot ) i++</li></ol><h3 id="为什么内层循环还需要判断i-lt-j"><a href="#为什么内层循环还需要判断i-lt-j" class="headerlink" title="为什么内层循环还需要判断i&lt;j"></a>为什么内层循环还需要判断i&lt;j</h3><p>如果数组为[5，1，2，3，6，7，8]，先j–，从后往前找到3后，再i++找，找到6后，再交换，此时会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>        quickSort(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>        System.out.println(Arrays.toString(a));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-comment">// 如果区间内没有元素，则直接return</span><br>        <span class="hljs-keyword">if</span> (low &gt;= high) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// p是基准的索引值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(a, low, high);<br>        <span class="hljs-comment">// 左边分区的递归</span><br>        quickSort(a, low, p - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 右边分区的递归</span><br>        quickSort(a, p + <span class="hljs-number">1</span>, high);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-comment">// 以左边的为基准元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> a[low];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> high;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-comment">// j 从右边开始，找比pivot小的元素下标</span><br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pivot) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">// i 从左边开始，找比pivot大的元素下标</span><br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) &#123;<br>                i++;<br>            &#125;<br>            swap(a, i, j);<br>        &#125;<br>        <span class="hljs-comment">// 将基准元素与j/i进行交换，此时i与j指向的是同一元素。</span><br>        swap(a, low, j);<br>        System.out.println(Arrays.toString(a));<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快排特点"><a href="#快排特点" class="headerlink" title="快排特点"></a>快排特点</h3><ol><li><p>平均时间复杂度是 O(nlog2^⁡n )，最坏时间复杂度 O(n^2)</p></li><li><p><strong>数据量较大时</strong>，优势非常明显</p></li></ol><p><strong>洛穆托分区方案 vs 霍尔分区方案</strong></p><ul><li>霍尔的移动次数平均来讲比洛穆托少3倍<h2 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h2></li></ul><p>稳定排序指，按对象中不同字段进行多次排序（如先按花色排序再按大小排序），<strong>不会打乱同值元素的顺序</strong>，不稳定排序则反之。<br><img src="https://img-blog.csdnimg.cn/44726d6565ac416a91c612f8dfdd47fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库优化复习（第三章）</title>
    <link href="/2022/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%A4%8D%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%89/"/>
    <url>/2022/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%A4%8D%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第三章："><a href="#第三章：" class="headerlink" title="第三章："></a>第三章：</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是DBMS中操作的基本执行单位，事务本身就是构成单一逻辑工作单元的数据库操作的有限序列，由一组DML语句INSERT、DELETE、 UPDATE组成。</p><p>在关系型数据库中，事务可以是一条、一组SQL语句，或整个程序。</p><p><strong>事务和程序的区别</strong>：程序包含多个事务。</p><p><strong>隐含事务</strong>与<strong>自动提交</strong>的SQL语句</p><ol><li><strong>DDL语句</strong>：ALTER, CREATE, RENAME, DROP, TRUNCATE </li><li><strong>用户权限管理操作</strong>：CREATE USER, GRANT, REVOKE, SET PASSWORD</li><li><strong>管理语句</strong>：ANALYZE TABLE, CHECK INDEX, REPAIR TABLE, LOAD INDEX INTO CACHE</li></ol><p><strong>命令：</strong></p><ol><li><strong>set autocommit&#x3D;0</strong>：关闭事务自动提交</li><li><strong>begin</strong>：开始事务</li><li><strong>commit</strong>：提交事务</li><li><strong>rollback</strong>：回滚事务</li><li><strong>start transaction</strong>：显示开启事务</li></ol><p>InnoDB存储引擎默认自动提交事务，隐式<strong>每行提交一次</strong>，<strong>效率极慢</strong>，<strong>当大量插入时发生错误无法回滚</strong>。</p><p>↑针对该案例进行优化，<strong>显式启动事务并提交</strong>，把循环体放入事务内避免循环提交。</p><p><img src="https://img-blog.csdnimg.cn/44ddf51287684e35825ffb62a86861da.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_17,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h3><ol><li><strong>原子性</strong>（Atomicity）：事务中的操作，要么都做，要么都不做，是不可分割的。原子性是事务概念的本质体现和基本要求。</li><li><strong>一致性</strong>（Consistency ）：事务执行的结果必须使数据库从一个一致性状态变到另一个一致性状态。</li><li><strong>隔离性</strong>（Isolation）：并发执行的各事务不能互相干扰。</li><li><strong>持续性</strong>（Durability）： 事务一旦提交，他对数据库的更新不再受后继操作或者故障的影响</li></ol><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><h4 id="事务读写中存在的问题"><a href="#事务读写中存在的问题" class="headerlink" title="事务读写中存在的问题"></a>事务读写中存在的问题</h4><p>MySQL作为多线程并发访问的数据库，当多个用户（多个事务）同时访问相同的数据库资源，也就是并发环境下，可能会出现以下几种不确定的情况。</p><ol><li><strong>脏读</strong>：一个事务读取了某行数据，而另外一个事务已经更新了此行的数据，但没有及时提交，<strong>例如，事务A读取了事务B更新的数据，随后事务B因为某些原因进行了回滚操作，那么事务A读取到的数据就是脏数据。</strong>这种情况是非常危险的，很可能造成所有的操作都被回滚。</li><li><strong>不可重复读</strong>：不可重复读指一个事务的修改和提交造成另一个事务在同一范围内的两次相同查询的返回结果不同。<strong>例如，事务A需要多次读取同一个数据，在事务A还没有结束时，事务B 访问并修改了该数据，那么，事务A两次读取到的数据就可能不一致</strong>，因此称为不可重复读。</li><li><strong>幻读</strong>：幻读是指一个线程中的事务读取到了另外一个线程中提交的INSERT数据。<strong>例如，用户A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是用户B此时插入了一条具体分数的记录，用户A修改完成后发现还有一条记录没有改过来</strong>，这种情况为幻读或者虚读。</li></ol><h4 id="MySQL中的事务隔离级别"><a href="#MySQL中的事务隔离级别" class="headerlink" title="MySQL中的事务隔离级别"></a>MySQL中的事务隔离级别</h4><table><thead><tr><th align="center">特性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ReadUncommitted 读未提交</td><td align="center">允许事务读取其他事务未提交的结果（即允许脏读），是事务隔离级别中等级最低的，也是最危险的，该级别<strong>很少用于实际应用</strong>。</td></tr><tr><td align="center">Read Committed      读已提交</td><td align="center">允许事务只能读取其他事务<strong>已经提交</strong>的结果，该隔离级别<strong>可以避免脏读</strong>，但<strong>不能避免重复读和幻读</strong>的情况。</td></tr><tr><td align="center">Repeatable Read               可重复读（默认）</td><td align="center">该级别确保了同一事务的多个实例在并发读取数据时，可以读取到同样的数据行。这种级别可以<strong>避免脏读和不可重复读</strong>的问题，但<strong>不能避免幻读</strong>的问题，是 MySQL <strong>默认的隔离级别</strong>。</td></tr><tr><td align="center">Serializable           可串行化</td><td align="center">强制性的对事务进行排序，使之不可能相互冲突，从而解决幻读的问题。实际上，这种方式是在每个读的数据行上<strong>加了共享锁</strong>，但这种级别可能<strong>会导致大量的超时现象</strong>和<strong>锁竞争</strong>，所以<strong>很少用于实际应用</strong>，是事务中最高的隔离级别</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/bd180a39df284377ba92505d576da3c2.png"></p><p>命令：</p><ol><li>SELECT @@tx_isolation; 查看当前会话的隔离级别（5.7）</li><li>SELECT @@transaction_isolation; 查看当前会话的隔离级别（8.0）</li><li>SET SESSION TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}：修改当前会话的隔离级别。</li></ol><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>锁机制主要是为了使用户<strong>对数据的访问变得有序</strong>，<strong>保证数据的一致性</strong>。锁机制是实现宏观上高并发最简单的方式，但从微观的角度来说，锁机制其实是<strong>读写串行化</strong>。</p><h4 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h4><p>锁的粒度是指<strong>锁的作用范围</strong>。InnoDB存储引擎支持表级锁以及行级锁，MyISAM存储引擎支持表级锁。</p><h4 id="隐式锁与显式锁"><a href="#隐式锁与显式锁" class="headerlink" title="隐式锁与显式锁"></a>隐式锁与显式锁</h4><p>MySQL自动加锁被称为隐式锁，数据库开发人员手动加锁被称为显式锁。</p><h4 id="MySQL的读写锁"><a href="#MySQL的读写锁" class="headerlink" title="MySQL的读写锁"></a>MySQL的读写锁</h4><p>读锁：读锁也被称为<strong>共享锁</strong>，允许其他用户对数据同时“读”，但不允许其他用户对数据同时“写”</p><p>写锁：写锁也被称为<strong>排他锁</strong>或者独占锁。写锁既不允许其他用户对数据同时“读”，也不允许其他用对数据同时“写”</p><h4 id="InnoDB的锁类型"><a href="#InnoDB的锁类型" class="headerlink" title="InnoDB的锁类型"></a>InnoDB的锁类型</h4><p><strong>表级锁</strong>：表级锁指<strong>整个表被客户锁定</strong>。表级锁分为<strong>读锁</strong>和<strong>写锁</strong>与<strong>意向锁</strong>。</p><ol><li>命令：LOCK TABLES table_name[AS alias]{READ [LOCAL]|[LOS_PRIORITY]WRITE}</li><li>READ：读锁定，确保用户<strong>可以读取表</strong>，但是<strong>不能修改表</strong>。</li><li>WRITE：写锁定，<strong>只有锁定该表的用户可以修改表</strong>，其他用户只能<strong>读取表</strong>。</li><li>意向锁：锁定的粒度是整张表。意向锁指如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。意向锁分为<strong>意向共享锁（IS）</strong>和<strong>意向排他锁（IX）</strong>两类。是<strong>MySQL自动的向该表加的锁</strong>。主要<strong>作用在于提高系统性能</strong>，不然第二个事务想加锁时每次要看表是否有被锁住，然后还要看行是否有被锁住，十分消耗性能。</li></ol><p><strong>行级锁</strong>：只有线程使用的<strong>行是被锁定的</strong>。表中的其他行对于其他线程都是可用的。行级锁分为<strong>读锁</strong>和<strong>写锁</strong>。</p><ol><li>READ：读锁定，确保用户<strong>可以读取表</strong>，但是<strong>不能修改表</strong>。</li><li>WRITE：写锁定，<strong>只有锁定该表的用户可以修改表</strong>，其他用户只能<strong>读取表</strong>。<br><img src="https://img-blog.csdnimg.cn/7041a59923c84756bc45995e188c0353.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></li></ol><p><strong>间隙锁：</strong>间隙锁（ Gap Lock）是 InnoDB 引擎在可重复读的隔离级别下<strong>为了解决幻读和数据误删问题</strong>而引入的锁机制。select * from test where id &gt; 0 and id &lt; 5 for update;时，如果表中不存在 id 为 2 的数据(只有1,3,4)，这个id&#x3D;2的数据被称为“间隙”， InnoDB引擎也会对这些“间隙”加锁。此时，如果事务T2执行 INSERT 语句，插入一条 id 为 2 的数据，则需要等到事务 T1结束才可以插入成功。</p><h4 id="锁命令"><a href="#锁命令" class="headerlink" title="锁命令"></a>锁命令</h4><p><strong>设置共享锁</strong>：SELECT * FROM 表名 WHERE 条件 LOCK IN SHARE MODE;</p><p><strong>设置排他锁</strong>：SELECT * FROM 表名 WHERE 条件 FOR UPDATE; （InnoDB引擎会自动在默认的修改语句update、delete、insert加上排他锁）</p><h4 id="锁等待"><a href="#锁等待" class="headerlink" title="锁等待"></a>锁等待</h4><p>锁等待是指在一个事务执行过程中，一个锁需要<strong>等到上一个事务的锁释放</strong>后才可以使用该资源。</p><p>参数：</p><ol><li><strong>innodb_lock_wait_timout</strong> ：锁等待时间参数</li><li><strong>select * from sys.innodb_lock_waits\G</strong>：查看锁等待发生情况</li><li><strong>show full processlist</strong>：输出线程id号</li></ol><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>在MySQL的InnoDB存储引擎中，当检测到死锁时，<strong>通常会使一个持有最少行级排它锁的事务释放锁并回滚，而让另一个事务获得锁并继续完成事务。</strong></p><h4 id="监控事务和锁"><a href="#监控事务和锁" class="headerlink" title="监控事务和锁"></a>监控事务和锁</h4><p>查看和监控事务、锁信息，可以通过执行<strong>show engine innodb status</strong> 命令。</p><p>MySQL将事务和锁信息记录在了<strong>information_schema</strong>数据库中，我们只需要查询即可。涉及的表主要有3个，即innodb_trx（查看事务情况）、innodb_locks（查询锁情况）、innodb_lock_waits（查看锁阻塞情况）。</p><p>MySQL5.6以上版本，可以设置innodb_print_all_deadlocks参数为1来记录死锁信息，并放到错误日志里。</p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p><strong>避免死锁的方法</strong></p><p>(I) 不同程序并发存取多个表或者涉及多行记录时，尽量<strong>约定以相同的顺序访问表</strong>， 可以大大降低死锁的机会。</p><p>(2) 对应用程序进行调整，在某些情况下，通过<strong>把大事务分解成多个小事务</strong>，使得<strong>锁能够更快被释放</strong>，及时提交或者回滚事务，可减少死锁发生的概率。</p><p>(3) 在同一个事务中，尽可能做到<strong>一次锁定所需要的所有资源</strong>，减少死锁产生的概率。</p><p>(4) 为表<strong>添加合理的索引</strong>，不用索引将会为表的每一行记录加上锁，死锁的概率大大增大。</p><p>(5) 对非常容易产生死锁的业务，可尝试<strong>升级锁粒度</strong>，通过表锁定来减少死锁产生的概率。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 可重复读隔离级别（RR级别）是否可以避免幻读</title>
    <link href="/2022/03/16/MySQL%20%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%88RR%E7%BA%A7%E5%88%AB%EF%BC%89%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB/"/>
    <url>/2022/03/16/MySQL%20%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%88RR%E7%BA%A7%E5%88%AB%EF%BC%89%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>在MySQL的A客户端中查看事务隔离级别(默认是RR级别)<br><img src="https://img-blog.csdnimg.cn/fb1d3479000645a19095add0887c305e.png"><br>在客户端A开启事务，并查看trax_learn表。<br><img src="https://img-blog.csdnimg.cn/ac2b0a8962d14061bc38f123ab03b2e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_19,color_FFFFFF,t_70,g_se,x_16"><br>新开一个客户端B，在trax_learn表中添加一条新数据<br><img src="https://img-blog.csdnimg.cn/b95042f4b1d54c0e92bc6142d90aa794.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_16,color_FFFFFF,t_70,g_se,x_16"><br>再次在客户端A中查看trax_learn表，发现，仍然是只有两条记录的。<br><img src="https://img-blog.csdnimg.cn/ac63e2974f70408c971d3f40752edb71.png"><br>在客户端A提交事务。commit，并再次查看。<br><img src="https://img-blog.csdnimg.cn/c1e6a58c98bf450d9a32cf89bb101fa5.png"><br>发现在客户端B中插入的数据显示出来了，说明客户端A在事务执行期间，客户端B对该表的操作并不会对客户端A有影响，避免了幻读。<br>出现这种情况的主要原因是因为普通的select语句是<strong>快照读</strong>，而事务A启动时，它的快照数据就已经被版本锁定了。 如果将事务A调整为<strong>当前读</strong>，就会产生幻读。</p><p>所以说InnoDB的RR隔离级别解决了幻读问题或没解决都不太准确。应该说它并<strong>没有完全解决</strong>幻读的问题。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java实现QQ邮箱验证码发送</title>
    <link href="/2022/03/16/Java%E5%AE%9E%E7%8E%B0QQ%E9%82%AE%E7%AE%B1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8F%91%E9%80%81/"/>
    <url>/2022/03/16/Java%E5%AE%9E%E7%8E%B0QQ%E9%82%AE%E7%AE%B1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8F%91%E9%80%81/</url>
    
    <content type="html"><![CDATA[<p>打开QQ邮箱里的POP&#x2F;SMTP服务<br><img src="https://img-blog.csdnimg.cn/dd2937155998478fbd3607f7bdb05150.png"><br>导入所需jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--QQ邮箱验证码所需jar包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.activation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.mail<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-email<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试，验证码可由工具类随机生成，这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.mail.EmailException;<br><span class="hljs-keyword">import</span> org.apache.commons.mail.SimpleEmail;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendEmail</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送邮件代码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetEmail 目标邮箱</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> authCode 验证码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEmailCode</span><span class="hljs-params">(String targetEmail, String authCode)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SimpleEmail</span> <span class="hljs-variable">mail</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleEmail</span>();<br>            <span class="hljs-comment">// 发送邮件的服务器</span><br>            mail.setHostName(<span class="hljs-string">&quot;smtp.qq.com&quot;</span>);<br>            <span class="hljs-comment">// 刚刚记录的授权码，是开启SMTP的密码</span><br>            mail.setAuthentication(<span class="hljs-string">&quot;source@qq.com&quot;</span>, <span class="hljs-string">&quot;授权码&quot;</span>);<br>            <span class="hljs-comment">// 发送邮件的邮箱和发件人</span><br>            mail.setFrom(<span class="hljs-string">&quot;source@qq.com&quot;</span>, <span class="hljs-string">&quot;桃花er&quot;</span>);<br>            <span class="hljs-comment">// 使用安全链接</span><br>            mail.setSSLOnConnect(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">// 接收的邮箱</span><br>            mail.addTo(targetEmail);<br>            <span class="hljs-comment">// 邮件的主题</span><br>            mail.setSubject(<span class="hljs-string">&quot;注册验证码&quot;</span>);<br>            <span class="hljs-comment">// 邮件的内容</span><br>            mail.setMsg(<span class="hljs-string">&quot;验证码为:&quot;</span> + authCode);<br>            <span class="hljs-comment">// 发送</span><br>            mail.send();<br>        &#125; <span class="hljs-keyword">catch</span> (EmailException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        sendEmailCode(<span class="hljs-string">&quot;taget@qq.com&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库优化复习（第一章）</title>
    <link href="/2022/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%A4%8D%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/"/>
    <url>/2022/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%A4%8D%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章："><a href="#第一章：" class="headerlink" title="第一章："></a><strong>第一章：</strong></h2><h3 id="数据库的性能优化"><a href="#数据库的性能优化" class="headerlink" title="数据库的性能优化"></a><strong>数据库的性能优化</strong></h3><ol><li>计算机系统的优化（硬件均衡）</li><li>SQL语句的优化（通过增加索引、设置参数让MySQL的执行计划更优）</li><li>架构的优化（<strong>最有效</strong>，读多写少可以设计为读写分离）</li></ol><h3 id="数据库发展阶段"><a href="#数据库发展阶段" class="headerlink" title="数据库发展阶段"></a><strong>数据库发展阶段</strong></h3><p>人工管理阶段 —&gt; 文件系统阶段 —&gt; 数据库发展阶段</p><h3 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a><strong>数据库的分类</strong></h3><p>关系型数据库<br><img src="https://img-blog.csdnimg.cn/7ddbab9b624c48209f9058fb722c39f4.png"><br>非关系型数据库<br><img src="https://img-blog.csdnimg.cn/a5b4da0c51a44571991d65a967dc07e1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_18,color_FFFFFF,t_70,g_se,x_16"></p><table><thead><tr><th align="center"></th><th align="center">关系型</th><th align="center">非关系型</th></tr></thead><tbody><tr><td align="center"><strong>优点</strong></td><td align="center"><strong>1、</strong>都是使用<strong>表结构</strong>易于维护；<strong>2、SQL语言通用</strong>，使用方便复杂操作；<strong>3、</strong>支持SQL，可用于一个表以及多个表之间非常<strong>复杂的查询</strong>。</td><td align="center"><strong>1、格式灵活</strong>：存储数据的格式可以是key,value形式、文档形式、图片形式等等；<strong>2、速度快</strong>；<strong>3、高扩展性</strong>；<strong>4、成本低</strong>：nosql数据库部署简单</td></tr><tr><td align="center"><strong>缺点</strong></td><td align="center"><strong>1、读写性能比较差</strong>；<strong>2</strong>、固定的表结构，<strong>灵活度</strong>稍欠；<strong>3</strong>、高并发读写需求，硬盘I&#x2F;O是一个很大的瓶颈。</td><td align="center"><strong>1、不提供sql支持</strong>，学习和使用成本较高；<strong>2、无事务处理</strong>；<strong>3</strong>、数据结构相对复杂，复杂查询方面稍欠。</td></tr></tbody></table><h3 id="主流版本与分支"><a href="#主流版本与分支" class="headerlink" title="主流版本与分支"></a><strong>主流版本与分支</strong></h3><p><strong>版本：</strong></p><p>2005年发布了 一个里程碑版本，即 MySQL 5.0 。在5.0中加入了游标、存储过程、触发器、视图和事务的支持。</p><p>2008年被Sun公司以10亿美金收购，2009年Oracle收购了Sun公司。</p><p>2010年MySQL5.5发布，InnoDB存储引擎变为MySQL的默认存储引擎。</p><p>2015年MySQL5.7GA发布，是到目前为止最新的稳定版本分支。</p><p><strong>分支：</strong></p><p><strong>Percona Server</strong>，它基于<strong>InnoDB存储引擎</strong>的基础上提升了性能和易管理性，最后形成了增强版的<strong>XtraDB</strong>引擎。</p><p><strong>MariaDB</strong>，MySQL有<strong>闭源</strong>的潜在风险，因此社区采用分支的方式来避开这个风险，用的是<strong>XtraDB</strong>引擎。</p><h3 id="一条查询语句在数据库的处理过程"><a href="#一条查询语句在数据库的处理过程" class="headerlink" title="一条查询语句在数据库的处理过程"></a><strong>一条查询语句在数据库的处理过程</strong></h3><p><img src="https://img-blog.csdnimg.cn/8fc0b1b6d73448d78f759cb4cefd55ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a><strong>MySQL逻辑架构</strong></h3><p>MySQL逻辑架构整体分为3层： </p><ol><li>第一层是<strong>客户端层</strong>（JDBC数据库连接池那些东西）</li><li>第二层是<strong>SQL层</strong></li><li>第三层是<strong>存储引擎层</strong></li></ol><p><img src="https://img-blog.csdnimg.cn/3a3649d7bb654c648e0e9837af7b1884.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><ol><li><p><strong>SQL层是MySQL的核心部分，通常也叫作核心服务层。</strong></p><p><strong>管理服务和工具组件</strong>：系统管理和控制工具从备份和恢复的安全性、复制、集群、管理、配置、迁移和元数据等方面管理数据库。</p><p><strong>SQL接口组件</strong>：进行DML、DDL，存储过程、视图、触发器等操作和管理；用户SQL命令接口。</p><p><strong>查询分析器组件</strong>：解析和验证SQL命令。</p><p><strong>查询优化器组件</strong>：对SQL语句查询进行优化。</p><p><strong>缓存和缓冲区</strong>：这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。</p></li><li><p><strong>存储引擎层</strong>：</p><p>MySQL的存储引擎是插件式的。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库优化复习（第二章）</title>
    <link href="/2022/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%A4%8D%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%89/"/>
    <url>/2022/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%A4%8D%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章："><a href="#第二章：" class="headerlink" title="第二章："></a><strong>第二章</strong>：</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a><strong>存储引擎</strong></h3><p>MySQL存储引擎实际上是个抽象类，文件访问层的一个抽象接口来定制种文件访问机制，这种访问机制就称为存储引擎，MySQL区别于其他数据库的最重要的特点，就是其插件式的存储引擎接口模块，<strong>可插拔存储引擎</strong>。</p><p>存储引擎可以分为MySQL官方存储引擎和第三方存储引擎。</p><p>MySQL官方最主流的存储引擎包括以下几种：</p><ol><li><strong>MyISAM</strong>存储引擎</li><li><strong>InnoDB</strong>存储引擎</li><li>Memory存储引擎</li><li>NDB存储引擎</li><li>Archive存储引擎</li></ol><h4 id="MyISAM存储引擎（面向OLAP类数据库应用）"><a href="#MyISAM存储引擎（面向OLAP类数据库应用）" class="headerlink" title="MyISAM存储引擎（面向OLAP类数据库应用）"></a><strong>MyISAM存储引擎（面向OLAP类数据库应用）</strong></h4><ol><li>存储限制：256TB</li><li><strong>不支持事务</strong>，不支持MVCC（多版本并发控制）</li><li>锁粒度：<strong>表级</strong></li><li>支持索引类型：B树索引，全文索引</li><li>复制支持，<strong>外键不支持</strong>，查询缓存支持</li><li><strong>访问速度快</strong>，有较好的索引优化和数据压缩技术</li></ol><p>MyISAM存储引擎表由MYD和MYI组成，<strong>MYD用来存放数据文件， MYI用来存放索引文件</strong>。</p><p>MySQL 5.0之前， MyISAM默认支持的表大小为4GB，MySQL 5.0之后，<strong>支持256TB的单表数据</strong>。</p><p>MyISAM缓冲池<strong>只缓存索引文件</strong>，而不缓冲数据文件。</p><h4 id="InnoDB存储引擎（面向OLTP类数据库应用）"><a href="#InnoDB存储引擎（面向OLTP类数据库应用）" class="headerlink" title="InnoDB存储引擎（面向OLTP类数据库应用）"></a><strong>InnoDB存储引擎（面向OLTP类数据库应用）</strong></h4><ol><li><strong>支持事务</strong>，支持MVCC（多版本并发控制）</li><li>锁粒度：<strong>行级</strong></li><li>支持索引类型：B树索引，<strong>自适应哈希索引</strong>、全文索引</li><li>复制支持，<strong>外键支持</strong>，查询缓存支持</li></ol><h4 id="MyISAM和InnoDB的区别："><a href="#MyISAM和InnoDB的区别：" class="headerlink" title="MyISAM和InnoDB的区别："></a><strong>MyISAM和InnoDB的区别：</strong></h4><p>MyISAM 保存有表的总行数，InnoDB 没有保存表的总行数。</p><p>MyISAM查询速度比InnoDB快很多。</p><h4 id="NDB存储引擎"><a href="#NDB存储引擎" class="headerlink" title="NDB存储引擎"></a><strong>NDB存储引擎</strong></h4><p>NDB存储引擎是一个<strong>集群存储引擎</strong>。</p><p>NDB的特点是<strong>数据全部放在内存中</strong>，因此<strong>主键查找的速度极快</strong>，是<strong>高可用、高性能</strong>的<strong>集群系统</strong>。</p><p>但是它的表的连接操作是在MySQL数据库层完成的，不是在存储引擎层完成的。这意味着复杂的连接操作需要巨大的网络开销，因此<strong>复杂查询速度会很慢</strong>，<strong>NDB存储引擎不支持事务</strong>。</p><h4 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a><strong>Memory存储引擎</strong></h4><p>Memory存储引擎将表中的<strong>数据存放在内存中</strong>，如果数据库重启或发生崩溃，表中的数据都将消失。</p><p>适合用于存储临时数据的临时表。</p><p>虽然Memory存储引擎<strong>速度非常快</strong>，但在使用上还是有一定的限制。比如<strong>只支持表锁</strong>，<strong>并发性能较差</strong>，<strong>不支持事务</strong>等。Memory存储引擎<strong>默认使用哈希索引</strong>，而不是B+树索引。</p><h4 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a><strong>Archive存储引擎</strong></h4><p>Archive存储引擎<strong>只支持INSERT和SELECT操作</strong>。使用zlib算法<strong>将数据行进行压缩后存储</strong>，压缩比一般可达1∶10。</p><p>Archive存储引擎非常适合存储归档数据，如日志信息。</p><p>Archive存储引擎<strong>是事务不安全</strong>的，其设计目标主要是<strong>提供高速的插入和压缩功能</strong>。</p><h3 id="引擎修改"><a href="#引擎修改" class="headerlink" title="引擎修改"></a><strong>引擎修改</strong></h3><p>转换表的存储引擎，<strong>会失去和原存储引擎相关的所有特性</strong>。例如，如果将一张InnoDB表转换为MyISAM，然后再转回InnoDB，原InnoDB表上的所有外键将消失。</p><h3 id="Innodb存储引擎体系结构"><a href="#Innodb存储引擎体系结构" class="headerlink" title="Innodb存储引擎体系结构"></a><strong>Innodb存储引擎体系结构</strong></h3><ol><li>缓冲池</li><li>change buffer</li><li>自适应哈希索引</li><li>redo log buffer</li><li>double write</li></ol><p>MySQL是通过WAL方式，来保证数据库事务的一致性和持久性。具体而言就是: </p><ol><li>修改记录前，一定要<strong>先写日志</strong>；</li><li>事务提交过程中，一定要<strong>保证日志先落盘</strong>，才能算事务提交完成。</li></ol><h4 id="InnoDB的缓冲池"><a href="#InnoDB的缓冲池" class="headerlink" title="InnoDB的缓冲池"></a><strong>InnoDB的缓冲池</strong></h4><p>InnoDB引擎使用<strong>缓冲池技术</strong>来提高数据库的整体性能（速度）。</p><p>InnoDB存储引擎有各种缓冲池, 这些缓冲块组成了个大的InnoDB储引擎内存池，<strong>主要负责的工作</strong>是</p><ol><li>维护所有进程／线程需要访问的多个内部数据结构；</li><li>缓存磁盘上的数据，<strong>方便快速读取</strong>，同时在对磁盘文件修改之前进行缓存；</li><li>重做日志缓存等。</li></ol><p>Innodb引擎中<strong>磁盘和内存</strong>之间数据交互的<strong>基本单位是数据页</strong>，<strong>默认大小是16KB</strong>。</p><p>Innodb引擎为<strong>每一个缓存页都创建了一个对应的块结构</strong>，块结构中存有该页面的表空间编号、页号等信息。</p><p>数据页通过<strong>LRU最近最少使用算法</strong>来进行换进换出操作。</p><p><strong>Buffer Pool的相关参数</strong></p><ol><li><strong>innodb_buffer_pool_size</strong> : Buffer Pool的总大小</li><li><strong>innodb_buffer_pool_instances</strong> : Buffer Pool中instance的数量，为了减轻高并发下锁争抢的压力，Buffer Pool分为多个instances。</li><li><strong>innodb_buffer_pool_chunk_size</strong> : chunk的大小，默认为128M，Mysql5.7版本后，Innodb引擎引入了chunk结构。Buffer Pool（扩大时）向操作系统申请一块连续的内存空间是chunk为单位向操作系统申请空间，chunk中存放缓存页的控制块和缓存页，还有管理这些缓存页的链表信息等。</li><li><strong>innodb_buffer_pool_dump_at_shutdown&#x3D;ON</strong>表示在关闭MySQL时会把内存中的热数据保存在磁盘里ib_buffer_pool文件中。</li><li><strong>innodb_buffer_pool_load_at_startup&#x3D;ON</strong>表示在启动时会自动加载热数据到Buffer_Pool缓冲池里。这样，始终保待热数据在内存中。</li></ol><h4 id="InnoDB的change-buffer"><a href="#InnoDB的change-buffer" class="headerlink" title="InnoDB的change buffer"></a><strong>InnoDB的change buffer</strong></h4><p>二级索引通常是非唯一的，插入顺序很随机，更新删除也都不是在邻近的位置，change buffer<strong>避免了很多随机I&#x2F;O的产生</strong>，将多次操作尽量变为少量的I&#x2F;O操作。</p><p>change buffer的相关参数：</p><ol><li><strong>innodb_change_buffering</strong>：缓存所对应的操作。</li><li><strong>innodb_change_buffer_max_size</strong>：用于配置 change buffer在Buffer Pool中所占的最大百分比。</li></ol><h4 id="InnoDB的自适应哈希索引"><a href="#InnoDB的自适应哈希索引" class="headerlink" title="InnoDB的自适应哈希索引"></a><strong>InnoDB的自适应哈希索引</strong></h4><p>lnnoDB存储引擎会监控对表上二级索引的查找。如果发现某二级索引被频繁访问，<strong>二级索引就成为热数据</strong>；如果建立哈希索引可以带来速度的提升，则建立哈希索引，所以称之为自适应的，即自适应哈希索引。MySQL自动管理，人为无法干预。</p><p>自适应哈希索引通过缓冲池的B+Tree构造而来</p><p>自适应哈希索引会占用 lnnoDB Buffer Pool。</p><p>通过”set global innodb_adaptive_hash_index off&#x2F;on” 命令来关闭或打开该功能。</p><h4 id="InnoDB的redo-log-buffer"><a href="#InnoDB的redo-log-buffer" class="headerlink" title="InnoDB的redo log buffer"></a><strong>InnoDB的redo log buffer</strong></h4><p>redo log buffer存放将要写入redo log文件的数据。其大小是通过设置。</p><p>参数：</p><ol><li>innodb_flush_log_at_trx_commit，控制redo log flush的频率 (0，1，2，安全性由低到高，性能由高到低) </li><li>innodb_log_buffer_size，设置redo log buffer的大小。</li></ol><h4 id="InnoDB的double-write"><a href="#InnoDB的double-write" class="headerlink" title="InnoDB的double write"></a><strong>InnoDB的double write</strong></h4><p>double write技术的引入是为了<strong>提高数据写入的可靠性</strong>。相对于随机写操作来说，顺序写入的代价较小。<strong>缺点</strong>是在新型的SSD存储中重复写入对SSD寿命有较大影响。</p><p>参数：</p><ol><li><strong>innodb_doublewrite&#x3D;0</strong>：关掉double write功能</li></ol><h3 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a><strong>事务提交</strong></h3><h4 id="事务提交过程"><a href="#事务提交过程" class="headerlink" title="事务提交过程"></a><strong>事务提交过程</strong></h4><p><strong>存储引擎实现事务</strong>的通用方式是基于 redo log 和 undo log。redo log 记录<strong>事务修改后的数据</strong>, undo log 记录<strong>事务前的原始数据</strong>。</p><p>事务执行时实际发生过程</p><ol><li>先记录 undo&#x2F;redo log，<strong>确保日志刷到磁盘上持久存储</strong>。</li><li><strong>更新</strong>数据记录，缓存操作并异步刷盘。</li><li><strong>提交事务</strong>，在 redo log 中写入 commit 记录。</li></ol><p>binlog 不在事务存储引擎范围内，所以在提交事务前需要将事务日志持久化到 binlog（更新后，提交前）。</p><h4 id="事务提交完后"><a href="#事务提交完后" class="headerlink" title="事务提交完后"></a><strong>事务提交完后</strong></h4><p>1、事务提交完后会<strong>purge undo段</strong>，purge的主要职能是，真正删除物理记录。（在执行delete或update操作时，实际<strong>旧记录没有真正删除</strong>（类似于is_deleted），只是在记录上打了一个标记，而是在事务提交后，purge线程真正删除）</p><p>2、<strong>释放锁资源</strong></p><p>3、刷redo日志。通过redo日志落盘操作，<strong>保证数据库的完整性和一致性</strong>；</p><p>4、<strong>清理保存点列表</strong>，每个语句实际都会有一个保存点，用来回滚的。</p><h3 id="InnoDB后台线程"><a href="#InnoDB后台线程" class="headerlink" title="InnoDB后台线程"></a><strong>InnoDB后台线程</strong></h3><p>InnoDB后台线程的主要作用是负责<strong>刷新内存池中的数据</strong>，保证缓冲池中的内存缓存的是最新数据。</p><h4 id="InnoDB主线程"><a href="#InnoDB主线程" class="headerlink" title="InnoDB主线程"></a><strong>InnoDB主线程</strong></h4><p><strong>master thread：</strong>主要工作是将缓冲池中的<strong>数据异步刷新到磁盘，保证数据的一致性</strong>，包括脏页的刷新、合并插入缓冲等。</p><p>master thread的线程优先级别最高，其内部由几个<strong>循环组成</strong>。master thread会根据数据运行的状态几个循环之间进行切换。</p><ol><li><strong>后台循环</strong><ol><li>删除无用Undo页（总是）</li><li>合并一定数量插入缓冲（总是）</li><li>若有用户活动，跳回主循环，否则，跳入刷新循环（总是）</li></ol></li><li><strong>刷新循环</strong><ol><li>将一定数量的脏页刷回磁盘（总是）</li><li>跳入暂停循环（总是）</li></ol></li><li><strong>暂停循环</strong><ol><li>将Master Thread挂起</li><li>若有事件发生，跳入主循环（总是）</li></ol></li></ol><h4 id="InnoDB后台I-x2F-O线程"><a href="#InnoDB后台I-x2F-O线程" class="headerlink" title="InnoDB后台I&#x2F;O线程"></a><strong>InnoDB后台I&#x2F;O线程</strong></h4><p>InnoDB存储引擎中大量使用AIO <strong>异步I&#x2F;O</strong>来处理I&#x2F;O请求，可以极大地<strong>提高数据库的性能</strong>。</p><p><strong>read thread</strong>负责将数据从磁盘加载到Buffer Pool的Page页。</p><p><strong>write thread</strong>负责将Buffer Pool的dirty page刷新到磁盘。</p><p><strong>log thread</strong>负责将Log Buffer内容刷新到磁盘。</p><p><strong>insert buffer thread</strong>负责将Change Buffer内容刷新到磁盘。</p><p>参数：可以在配置文件 my.cnf 中设置</p><ol><li>innodb_read_io_threads</li><li>Innodb_write_io_threads</li></ol><h4 id="InnoDB脏页刷新线程"><a href="#InnoDB脏页刷新线程" class="headerlink" title="InnoDB脏页刷新线程"></a><strong>InnoDB脏页刷新线程</strong></h4><p>MySQL5.6前，脏页清理工作由<strong>master线程</strong>处理。5.6之后是由<strong>page cleaner thread</strong>实现缓冲池刷脏页的工作。</p><p>参数：</p><ol><li><strong>innodb_page_cleaners</strong>：设置脏页刷新线程数。（5.7.4版本后引入了多个page cleaner线程）</li><li><strong>Innodb_buffer_pool_wait_free</strong>：标志脏页有没有成为系统的性能瓶颈。如果innodb_buffer_pool_size够大，就可以让Innodb_buffer_pool_wait_free的值很小，甚至为0。</li></ol><h4 id="InnoDB-purge线程"><a href="#InnoDB-purge线程" class="headerlink" title="InnoDB purge线程"></a><strong>InnoDB purge线程</strong></h4><p><strong>purge thread</strong>负责回收已经使用并分配的undo页（记录原始数据）。</p><p>例外：</p><ol><li><strong>insert undo log</strong>是不需要purge的，因为insert操作只对本事务可见，所以提交事务后就直接删除了。</li><li><strong>update undo log</strong>是delete update操作产生的，后续MVCC可能会用到，所以不能在提交时候删除。它会放入undo log的链表，等待purge<strong>最后删除</strong>。</li></ol><p>当删除和更新数据行时，对数据页中要删除的数据行做标记”deleted”，事务提交速度快；后台线程purge线程对数据页中有 “deleted” 标签的数据行进行真正的删除。</p><p>参数：</p><ol><li><strong>innodb_purge_threads</strong>：可以调整并发的purge线程数。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务学习</title>
    <link href="/2022/03/16/MySQL%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/03/16/MySQL%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>查看数据库中自动提交事务是否打开，默认是自动提交的。<br><img src="https://img-blog.csdnimg.cn/055b262c871e40c5ac591293e311de50.png"></p><p>这里将自动提交事务关闭，使用命令set autocommit&#x3D;0;（注意：这里只是关闭当前会话的自动提交事务，退出客户端后，再次进入依然是自动提交事务的）<br><img src="https://img-blog.csdnimg.cn/9877c8f604854c82992ed0c82daf111d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_14,color_FFFFFF,t_70,g_se,x_16"></p><p>设计一个叫trax_learn的表，并插入两条数据<br><img src="https://img-blog.csdnimg.cn/28de0abbdaa7459b81696dedbb863d0c.png"><br><img src="https://img-blog.csdnimg.cn/1bfbdab9b70e44318a0fe4e16ed785e9.png"><br>使用update语句，让Tom转账1000元给LTH用户。因为关闭了自动提交事务，所以这里要使用begin命令和commit命令来进行事务的提交。<br><img src="https://img-blog.csdnimg.cn/bae8ff0472c44d4f824acacc1eeb7c95.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_19,color_FFFFFF,t_70,g_se,x_16"></p><p>可以发现转账成功。<br>接下来模拟事务回滚，Tom再次向LTH转账1000元，但是未进行commit，直接退出了客户端。<br><img src="https://img-blog.csdnimg.cn/17ce3e54dbf4464b9f6aee36b57bd64d.png"></p><p>再次打开客户端，可以发现转账失败了，系统进行了自动回滚的操作。<br><img src="https://img-blog.csdnimg.cn/557439d21216461b9d733c6f0321dd51.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB学习之与修改Buffer Pool参数</title>
    <link href="/2022/03/16/InnoDB%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%8E%E4%BF%AE%E6%94%B9Buffer%20Pool%E5%8F%82%E6%95%B0/"/>
    <url>/2022/03/16/InnoDB%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%8E%E4%BF%AE%E6%94%B9Buffer%20Pool%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>查询当前版本的MySQL支持哪些存储引擎<br><img src="https://img-blog.csdnimg.cn/06cbb29f2edf41ef9161d15d5a316e9d.png"><br>查询InnoDB存储引擎的一些基本参数，如Buffer Pool的总大小，这里使用模糊查询来查询相关参数。</p><p><img src="https://img-blog.csdnimg.cn/389c578027fc42eb810274201034367d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_13,color_FFFFFF,t_70,g_se,x_16"></p><p>也可以通过可视化工具来查看或修改，这里使用Navicat来查看，可以发现innodb_buffer_pool_size和innodb_buffer_pool_chunk_size都为134217728B，也就是说134217728B&#x2F;1024&#x2F;1024&#x3D;128MB，这里MySQL设置的是默认128MB。<br><img src="https://img-blog.csdnimg.cn/93faba0a76684127bcd3a1077c3af115.png"></p><p>修改innodb_buffer_pool_size如果是5.7版本以前需要到my.cnf中去修改然后重启mysql进程才可以生效<br><img src="https://img-blog.csdnimg.cn/95cb9a8bd0f44ee791ff42cd52cd2dab.png"><br><img src="https://img-blog.csdnimg.cn/e363f0f68d0a404db09fcda61d8ace27.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>使用cat命令可以发现，在注释的地方标记了innodb_buffer_pool_size为128MB.<br>因为这里我使用的是MySQL 8.0的版本，所以可以直接动态修改Buffer Pool的大小。<br>使用命令set global innodb_buffer_pool_size &#x3D; 268435456将Buffer Pool的大小调整为256MB。<br><img src="https://img-blog.csdnimg.cn/2a1484f3d96444d0953ebcb3a8f8d525.png"><br>查看，可以发现已经修改成功。<br><img src="https://img-blog.csdnimg.cn/df4b40dd80934e018a32e5a1ceee79ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_14,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/c2acdff6877b4c08b8437aa65f338b8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_17,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canal启动失败</title>
    <link href="/2022/03/12/canal%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/"/>
    <url>/2022/03/12/canal%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<p>阿里云设置安全组后，在Linux机器上防火墙开启端口号</p><p>开启端口</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java">firewall-cmd --zone=<span class="hljs-keyword">public</span> --add-port=<span class="hljs-number">8001</span>/tcp --permanent<br></code></pre></td></tr></table></figure><p>重启防火墙：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>查询端口号8001是否开启：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">firewall-cmd --query-port=<span class="hljs-number">8001</span>/tcp<br></code></pre></td></tr></table></figure><p>查询有哪些端口是开启的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">firewall-cmd --list-port<br></code></pre></td></tr></table></figure><p>关闭端口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">firewall-cmd --zone=<span class="hljs-keyword">public</span> --remove-port=<span class="hljs-number">8001</span>/tcp --permanent<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
      <tag>canal</tag>
      
      <tag>主从同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux上打开，关闭，查看防火墙</title>
    <link href="/2022/03/03/Linux%E4%B8%8A%E6%89%93%E5%BC%80%EF%BC%8C%E5%85%B3%E9%97%AD%EF%BC%8C%E6%9F%A5%E7%9C%8B%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <url>/2022/03/03/Linux%E4%B8%8A%E6%89%93%E5%BC%80%EF%BC%8C%E5%85%B3%E9%97%AD%EF%BC%8C%E6%9F%A5%E7%9C%8B%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java设计模式（第五章：单例模式）</title>
    <link href="/2022/01/19/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%89/"/>
    <url>/2022/01/19/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第五章：单例设计模式"><a href="#第五章：单例设计模式" class="headerlink" title="第五章：单例设计模式"></a>第五章：单例设计模式</h2><h3 id="5-1-单例设计模式介绍"><a href="#5-1-单例设计模式介绍" class="headerlink" title="5.1 单例设计模式介绍"></a>5.1 单例设计模式介绍</h3><p>单例设计模式：就是采取一定的方法保证在整个的软件系统种，对某个类只能存在一个对象实例，并且该类对系统只提供一个取得其对象实例的方法（静态方法）。</p><h3 id="5-2-单例设计模式要点："><a href="#5-2-单例设计模式要点：" class="headerlink" title="5.2 单例设计模式要点："></a>5.2 单例设计模式要点：</h3><h4 id="5-2-1-第一点：某个类只能有一个实例"><a href="#5-2-1-第一点：某个类只能有一个实例" class="headerlink" title="5.2.1 第一点：某个类只能有一个实例"></a>5.2.1 第一点：某个类只能有一个实例</h4><p>某个类只能有一个实例  ——&gt;  构造器私有化</p><h4 id="5-2-2-第二点：它必须自行创建这个实例"><a href="#5-2-2-第二点：它必须自行创建这个实例" class="headerlink" title="5.2.2 第二点：它必须自行创建这个实例"></a>5.2.2 第二点：它必须自行创建这个实例</h4><p>它必须自行创建这个实例  ——&gt;  含有一个该类的静态变量来保存这个唯一的实例</p><h4 id="5-2-3-第三点：它必须自行向整个系统提供这个实例"><a href="#5-2-3-第三点：它必须自行向整个系统提供这个实例" class="headerlink" title="5.2.3 第三点：它必须自行向整个系统提供这个实例"></a>5.2.3 第三点：它必须自行向整个系统提供这个实例</h4><p>它必须自行向整个系统提供这个实例  ——&gt;  两种方法</p><p>对外提供获取该实例对象的方式：①直接暴露(变量权限为public)，②用静态变量的get方法获取(变量权限为private，方法权限为public)。</p><h4 id="5-2-4-第四点：强调这是一个单例"><a href="#5-2-4-第四点：强调这是一个单例" class="headerlink" title="5.2.4 第四点：强调这是一个单例"></a>5.2.4 第四点：强调这是一个单例</h4><p>强调这是一个单例  ——&gt;  用final来修饰</p><h3 id="5-3-单例设计模式八种方式"><a href="#5-3-单例设计模式八种方式" class="headerlink" title="5.3 单例设计模式八种方式"></a>5.3 单例设计模式八种方式</h3><ol><li>&#x3D;&#x3D;饿汉式（静态常量）&#x3D;&#x3D;</li><li>&#x3D;&#x3D;饿汉式（静态代码块）&#x3D;&#x3D;</li><li>懒汉式（线程不安全）</li><li>懒汉式（线程安全，同步方法）</li><li>懒汉式（线程安全，同步代码块）</li><li>&#x3D;&#x3D;双重检查&#x3D;&#x3D;</li><li>&#x3D;&#x3D;静态内部类&#x3D;&#x3D;</li><li>&#x3D;&#x3D;枚举&#x3D;&#x3D;</li></ol><h3 id="5-4-饿汉式（静态常量）："><a href="#5-4-饿汉式（静态常量）：" class="headerlink" title="5.4 饿汉式（静态常量）："></a>5.4 饿汉式（静态常量）：</h3><p><strong>步骤：</strong>①<strong>构造器私有化</strong>  ——&gt;  ②类<strong>内部创建</strong>对象  ——&gt;  ③向外暴露一个<strong>静态</strong>的<strong>公共</strong>方法getInstance()</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton1</span> <span class="hljs-variable">INSTANCE_1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton1</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton1</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE_1;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//测试，发现instance和instance2的哈希值是一致的，这两个变量都是同一个对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Singleton1</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton1.getInstance();<br>    <span class="hljs-type">Singleton1</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singleton1.getInstance();<br>    System.out.println(instance == instance2);<span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li><p>优点：写法简单，类加载的时候就完成实例化，避免了线程同步的问题。</p></li><li><p>缺点：在类加载的时候就完成实例化，没有达到Lazy Loading懒加载的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p></li><li><p>这种方式基于ClassLoader类装载机制避免了多线程的同步问题，不过instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他方式（其他的静态方法）导致类加载，这时候初始化instance就没有达到Lazy Loading的效果。</p></li></ul><p><strong>总结</strong>：这种单例模式可用，不过有可能造成内存的浪费。</p><h3 id="5-5-饿汉式（静态代码块）："><a href="#5-5-饿汉式（静态代码块）：" class="headerlink" title="5.5 饿汉式（静态代码块）："></a>5.5 饿汉式（静态代码块）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton2 INSTANCE_2;<br>    <span class="hljs-keyword">private</span> String info;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Singleton2.class.getClassLoader();<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> classLoader.getResourceAsStream(<span class="hljs-string">&quot;single.properties&quot;</span>);<br>            properties.load(is);<br>            INSTANCE_2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton2</span>(properties.getProperty(<span class="hljs-string">&quot;info&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton2</span><span class="hljs-params">(String info)</span> &#123;<br>        <span class="hljs-built_in">this</span>.info = info;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInfo</span><span class="hljs-params">(String info)</span> &#123;<br>        <span class="hljs-built_in">this</span>.info = info;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Singleton2&#123;info=&#x27;&quot;</span> + info + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE_2;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//测试：修改了实例的内容后，可以发现，两个变量实际上是指向同一个内存空间的，哈希值也未曾发生改变</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSingleton2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Singleton2</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Singleton2.getInstance();<br>    <span class="hljs-type">Singleton2</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> Singleton2.getInstance();<br>    System.out.println(s);<br>    System.out.println(s.hashCode());<br>    s2.setInfo(<span class="hljs-string">&quot;abcde&quot;</span>);<br>    System.out.println(s);<br>    System.out.println(s2.hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>优点：单例类在创建实例时可能需要调用其他地方的变量进行实例化，所以需要使用静态代码块来做处理。</li><li>缺点：与5.4饿汉式静态常量创建一致。</li></ul><p><strong>总结</strong>：这种单例模式可用，不过有可能造成内存的浪费。</p><h3 id="5-6-关于饿汉式是否需要加final的分析"><a href="#5-6-关于饿汉式是否需要加final的分析" class="headerlink" title="5.6 关于饿汉式是否需要加final的分析"></a>5.6 关于饿汉式是否需要加final的分析</h3><p>如果存在释放资源的情况下，就不能加final修饰了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseInstance</span><span class="hljs-params">()</span>&#123; <br>    <span class="hljs-keyword">if</span>(INSTANCE_1 != <span class="hljs-literal">null</span>)&#123; <br>        INSTANCE_1 = <span class="hljs-literal">null</span>; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>释放资源之后，如果需要重新使用这个单例，就必须存在重新初始化的过程，所以不能加final。对于不需要释放资源的情况，可以加final。总而言之，要不要加final修饰，可以根据情况而定。<br><img src="https://img-blog.csdnimg.cn/5a7ac573b115407da5bf618ffc9a7759.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="5-7-懒汉式（线程不安全）"><a href="#5-7-懒汉式（线程不安全）" class="headerlink" title="5.7 懒汉式（线程不安全）"></a>5.7 懒汉式（线程不安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton3</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton3 instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton3</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton3 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton3</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>优点：起到了Lazy Loading懒加载的效果，但是只能在<strong>单线程</strong>下使用。</li><li>缺点：在多线程下，如果一个线程进入了if(instance &#x3D;&#x3D; null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这个时候便会<strong>产生多个实例</strong>。所以说在多线程环境下不可以使用这种方式。</li></ul><p><strong>总结</strong>：在实际开发中，<strong>不要使用</strong>这种方式。</p><h3 id="5-8-懒汉式（线程安全，同步方法）"><a href="#5-8-懒汉式（线程安全，同步方法）" class="headerlink" title="5.8 懒汉式（线程安全，同步方法）"></a>5.8 懒汉式（线程安全，同步方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton4</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton4 instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton4</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton4 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton4</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>优点：解决了<strong>线程安全</strong>的问题。</li><li>缺点：<strong>效率低</strong>，每个线程在想要获取到类实例的时候，执行getInstance方法都需要进行同步。而这个方法只执行一次实例化代码就够了，后面的想获得该类的实例，直接return就行了。<strong>方法进行同步效率太低。</strong></li></ul><p><strong>总结</strong>：在实际开发中，<strong>不推荐</strong>这种方式。</p><h3 id="5-9-懒汉式（线程安全，同步代码块）"><a href="#5-9-懒汉式（线程安全，同步代码块）" class="headerlink" title="5.9 懒汉式（线程安全，同步代码块）"></a>5.9 懒汉式（线程安全，同步代码块）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton5</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton5 instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton5</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton5 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (Singleton5.class) &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton5</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：与同步方法其实是一致的，无差别。</p><h3 id="5-10-双重检查"><a href="#5-10-双重检查" class="headerlink" title="5.10 双重检查"></a>5.10 双重检查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton6</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton6 instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton6</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton6 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton6.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton6</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>优点：<ul><li>Double-Check双重检查概念是多线程开发种常使用到的，由代码中可见我们进行了两次if(instance &#x3D;&#x3D; null)检查，这样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断if(instance &#x3D;&#x3D; null)，直接return实例化对象，也避免的反复进行方法同步。</li><li><strong>线程安全，延迟加载，效率较高</strong>。</li></ul></li></ul><p><strong>总结</strong>：在实际开发中，<strong>推荐使用</strong>这种单例设计模式。</p><h3 id="5-11-关于双重检查是否需要加volatile的分析"><a href="#5-11-关于双重检查是否需要加volatile的分析" class="headerlink" title="5.11 关于双重检查是否需要加volatile的分析"></a>5.11 关于双重检查是否需要加volatile的分析</h3><p>当一个变量定义为volatile之后，它将具备两种特性。</p><ol><li>保证此变量对所有线程的可见性 <ul><li><strong>解释</strong>：当一个线程修改了volatile变量之后，<strong>它先写入它的工作内存中，然后立刻写入主内存，并且刷新其他线程中的工作内存</strong>，这样其他线程再去读取他们工作内存中的变量时，确保能够拿到最新的。</li></ul></li><li>禁止指令重排序优化 <ul><li><strong>解释</strong>：计算机由于cpu的执行速度与内存的读取速度差异太大，而又无法从硬件上获得突破，所以cpu的乱序执行出现了，在指令没有依赖的情况下，由cpu自动的对代码进行优化，提高cpu的执行效率。使用volatile后可以<strong>阻碍指令的重排序</strong>。</li></ul></li></ol><p>JVM中instance的创建过程：instance&#x3D;new Singleton6()不是一个原子操作，分为三个指令操作。</p><ol><li>给instance分配内存</li><li>调用构造函数来初始化成员变量，形成实例</li><li>将instance对象指向分配的内存空间</li></ol><p>经过指令重排序后，如果先执行1，3指令，再执行2指令。<strong>instance已经不为null了，但是它还没有初始化这个实例，那么其他线程这个时候执行返回的instance就是错误的了</strong>。所以需要加上volatile关键字。</p><h3 id="5-12-静态内部类"><a href="#5-12-静态内部类" class="headerlink" title="5.12 静态内部类"></a>5.12 静态内部类</h3><p>静态内部类不会自动随着外部类的加载和初始化而初始化，它是要单独去加载和初始化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton7</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton7</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonInstance</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton7</span> <span class="hljs-variable">INSTANCE_7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton7</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton7 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonInstance.INSTANCE_7;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>优点：<ul><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li><li>静态内部类方式在Singleton7类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法会装载SingletonInstance类，从而完成Singleton7的实例化。</li><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了现场的安全性，在类进行初始化时，别的线程时无法进入的。</li><li><strong>线程安全，利用静态内部类特点实现延迟加载，效率较高</strong>。</li></ul></li></ul><p><strong>总结</strong>：在实际开发中，<strong>推荐使用</strong>这种单例设计模式。</p><h3 id="5-13-枚举"><a href="#5-13-枚举" class="headerlink" title="5.13 枚举"></a>5.13 枚举</h3><p>枚举类型：表示该类型的对象是有限的几个</p><p>我们可以限定为一个，就成了单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton8</span> &#123;<br>    INSTANCE_8;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayOk</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>优点：<ul><li>这借助了JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</li></ul></li></ul><p><strong>总结</strong>：在实际开发中，<strong>推荐使用</strong>这种单例设计模式。</p><h3 id="5-14-单例模式在JDK应用的源码分析"><a href="#5-14-单例模式在JDK应用的源码分析" class="headerlink" title="5.14 单例模式在JDK应用的源码分析"></a>5.14 单例模式在JDK应用的源码分析</h3><p>JDK中的Runtime就是经典的单例模式（饿汉式）<br><img src="https://img-blog.csdnimg.cn/89f8e48e51734195848cdbb517f85991.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="5-15-单例模式注意事项和细节说明"><a href="#5-15-单例模式注意事项和细节说明" class="headerlink" title="5.15 单例模式注意事项和细节说明"></a>5.15 单例模式注意事项和细节说明</h3><ol><li>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</li><li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是new</li><li>单例模式<strong>使用的场景</strong>：需要<strong>频繁的进行创建和销毁的对象</strong>，创建对象时耗时过多或耗费资源过多（即&#x3D;&#x3D;重量级对象&#x3D;&#x3D;），但又经常用到的对象，&#x3D;&#x3D;工具类对象&#x3D;&#x3D;，频繁访问数据库或文件的对象（比如&#x3D;&#x3D;数据源&#x3D;&#x3D;，&#x3D;&#x3D;session工厂&#x3D;&#x3D;等）</li><li>如果是饿汉式，<strong>枚举形式</strong>最简单。如果是懒汉式，<strong>静态内部类</strong>形式最简单</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java设计模式（第四章）</title>
    <link href="/2022/01/19/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%89/"/>
    <url>/2022/01/19/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第四章：设计模式概述"><a href="#第四章：设计模式概述" class="headerlink" title="第四章：设计模式概述"></a>第四章：设计模式概述</h2><h3 id="4-1-设计模式介绍"><a href="#4-1-设计模式介绍" class="headerlink" title="4.1 设计模式介绍"></a>4.1 设计模式介绍</h3><p>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案。</p><p>设计模式的本质是为了提高软件的维护性，通用性和扩展性，并降低软件的复杂度。</p><h3 id="4-2-设计模式类型"><a href="#4-2-设计模式类型" class="headerlink" title="4.2 设计模式类型"></a>4.2 设计模式类型</h3><p>设计模式分为三种类型，共23种</p><ol><li><strong>创建型模式</strong>：单例模式，&#x3D;&#x3D;抽象工厂模式&#x3D;&#x3D;，原型模式，建造者模式，&#x3D;&#x3D;工厂模式&#x3D;&#x3D;。</li><li><strong>结构型模式</strong>：适配器模式，桥接模式，&#x3D;&#x3D;装饰模式&#x3D;&#x3D;，组合模式，外观模式，享元模式，&#x3D;&#x3D;代理模式&#x3D;&#x3D;。</li><li><strong>行为型模式</strong>：模板方法模式，命令模式，访问者模式，迭代器模式，&#x3D;&#x3D;观察者模式&#x3D;&#x3D;，中介者模式，备忘录模式，解释器模式（Interpreter模式），状态模式，策略模式，职责链模式（责任链模式）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java设计模式（第三章：UML类图）</title>
    <link href="/2022/01/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AUML%E7%B1%BB%E5%9B%BE%EF%BC%89/"/>
    <url>/2022/01/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AUML%E7%B1%BB%E5%9B%BE%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第三章：UML类图"><a href="#第三章：UML类图" class="headerlink" title="第三章：UML类图"></a>第三章：UML类图</h2><h3 id="3-1-UML基本介绍"><a href="#3-1-UML基本介绍" class="headerlink" title="3.1 UML基本介绍"></a>3.1 UML基本介绍</h3><p>UML–Unified modeling language(统一建模语言)，本身就是一套符号的规定，这些符号用于描述软件模型中的各个元素和他们之间的关系，六大关系：依赖，泛化(继承)，实现，关联，聚合，组合等。</p><p><img src="https://img-blog.csdnimg.cn/32c1e280d6e34d31a0b0548efeea3304.png"></p><h3 id="3-2-六种关系"><a href="#3-2-六种关系" class="headerlink" title="3.2 六种关系"></a>3.2 六种关系</h3><h4 id="3-2-1-依赖关系："><a href="#3-2-1-依赖关系：" class="headerlink" title="3.2.1 依赖关系："></a>3.2.1 依赖关系：</h4><p><strong>只要是在类中用到了对方，那么他们之间就存在依赖关系</strong>。</p><p>条件：类中用到了对方，类的成员属性(PersonDao)，方法的返回类型(IDCard)，方法接收的参数类型(Person)，方法中使用到(Department)。</p><p><img src="https://img-blog.csdnimg.cn/3164607d2489424ebd67df4dd511df86.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="3-2-2-泛化关系："><a href="#3-2-2-泛化关系：" class="headerlink" title="3.2.2 泛化关系："></a>3.2.2 泛化关系：</h4><p><strong>泛化关系实际上就是继承关系，它是依赖关系的特例</strong>。</p><p>如果A继承了B，我们就说<strong>A和B存在泛化关系</strong>。</p><p><img src="https://img-blog.csdnimg.cn/10d1483a334243148c54279e1c2a4d33.png"></p><h4 id="3-2-3-实现关系："><a href="#3-2-3-实现关系：" class="headerlink" title="3.2.3 实现关系："></a>3.2.3 实现关系：</h4><p>实现关系实际上就是<strong>A类实现了B接口，它是依赖关系的特例</strong>。</p><p><img src="https://img-blog.csdnimg.cn/547b55c2e21146249e8a80b54d28065c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_15,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="3-2-4-关联关系："><a href="#3-2-4-关联关系：" class="headerlink" title="3.2.4 关联关系："></a>3.2.4 关联关系：</h4><p>关联关系实际上就是<strong>类与类之间的联系，它是依赖关系的特例</strong>。</p><p>关联关系的<strong>导航性</strong>：即双向关系或单向关系。</p><p>关联关系的<strong>多重性</strong>：如”1”（表示有且仅有一个）， “0…”（表示0个或多个），”0, 1”（表示0个或1个），”n…m”（表示n个到m个都可以），”m…*”（表示至少m个）。</p><p><img src="https://img-blog.csdnimg.cn/b9c99a78a91e40758d8c0dd71f9427ad.png"><br><img src="https://img-blog.csdnimg.cn/8477fe6903e54b63ab075a62cabf9486.png"></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单向一对一关系</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">private</span> IdCard card;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdCard</span>&#123;&#125;<br><br><span class="hljs-comment">//双向一对一关系</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">private</span> IdCard card;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdCard</span>&#123;<br>    <span class="hljs-keyword">private</span> Person person;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-5-聚合关系："><a href="#3-2-5-聚合关系：" class="headerlink" title="3.2.5 聚合关系："></a>3.2.5 聚合关系：</h4><p>聚合关系表示的是<strong>整体和部分的关系，整体和部分可以分开，它是关联关系的特例，同样具有导航性和多重性</strong>。</p><p><strong>部分死，整体不死。</strong></p><p><img src="https://img-blog.csdnimg.cn/0527419eff0f4417b67bf604e1f873bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_12,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="3-2-6-组合关系："><a href="#3-2-6-组合关系：" class="headerlink" title="3.2.6 组合关系："></a>3.2.6 组合关系：</h4><p>组合关系表示的是<strong>整体和部分的关系，整体和部分不可以分开，它是关联关系的特例</strong>。</p><p><strong>部分死，整体死</strong>。也就是说在类的成员变量中直接new了出来，而不是简单的声明。</p><p><img src="https://img-blog.csdnimg.cn/b7ed562d7b44464d86d7d6a866069b3c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_13,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java设计模式（第二章：七大原则）</title>
    <link href="/2022/01/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%89/"/>
    <url>/2022/01/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章：设计模式七大原则"><a href="#第二章：设计模式七大原则" class="headerlink" title="第二章：设计模式七大原则"></a>第二章：设计模式七大原则</h2><h3 id="2-1-设计模式的目的"><a href="#2-1-设计模式的目的" class="headerlink" title="2.1 设计模式的目的"></a>2.1 设计模式的目的</h3><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序具有更好的代码重用性，可读性，可扩展性，可靠性，使程序呈现高内聚，低耦合的特性。</p><h3 id="2-2-设计模式七大原则"><a href="#2-2-设计模式七大原则" class="headerlink" title="2.2 设计模式七大原则"></a>2.2 设计模式七大原则</h3><p>设计模式原则，其实就是<strong>程序员在编程时，应当遵守的原则</strong>，也是各种<strong>设计模式的基础</strong>(即：<strong>设计模式为什么这样设计的依据</strong>)。</p><p>设计模式常用的七大原则有：</p><ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转原则</li><li>里氏替换原则</li><li>开闭原则ocp</li><li>迪米特法则</li><li>合成复用原则</li></ol><h3 id="2-3-单一职责原则"><a href="#2-3-单一职责原则" class="headerlink" title="2.3 单一职责原则"></a>2.3 单一职责原则</h3><h4 id="2-3-1-基本介绍："><a href="#2-3-1-基本介绍：" class="headerlink" title="2.3.1 基本介绍："></a>2.3.1 基本介绍：</h4><p>对类来说的，<strong>即一个类应该只负责一项职责</strong>，如类A负责两个不同的职责，当职责1需求变更再改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。</p><h4 id="2-3-2-汽车飞机船案例-pdf"><a href="#2-3-2-汽车飞机船案例-pdf" class="headerlink" title="2.3.2 汽车飞机船案例(pdf)"></a>2.3.2 汽车飞机船案例(pdf)</h4><h4 id="2-3-3-单一职责原则注意事项和细节："><a href="#2-3-3-单一职责原则注意事项和细节：" class="headerlink" title="2.3.3 单一职责原则注意事项和细节："></a>2.3.3 单一职责原则注意事项和细节：</h4><ol><li>降低类的复杂度，一个类负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别违反单一职责原则；</li><li><strong>只有类中方法数量足够少，可以在方法级别保持单一职责原则</strong>。</li></ol><h3 id="2-4-接口隔离原则"><a href="#2-4-接口隔离原则" class="headerlink" title="2.4 接口隔离原则"></a>2.4 接口隔离原则</h3><h4 id="2-4-1-基本介绍："><a href="#2-4-1-基本介绍：" class="headerlink" title="2.4.1 基本介绍："></a>2.4.1 基本介绍：</h4><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。通俗来讲就是<strong>一个类通过接口去依赖另外一个类，应该建立在粒度最小接口上。 避免没必要的依赖，既然依赖就要将接口中所有方法全部使用到，否则将接口进行拆分。</strong><br><img src="https://img-blog.csdnimg.cn/c5e21d582eba4d03b74897f2722025d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_15,color_FFFFFF,t_70,g_se,x_16"></p><p>类A通过接口Interface1依赖类B，类C通过接口interface1依赖类D，如果接口Interface1对于类来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。</p><p>所以说<strong>按照隔离原则应当将接口Interface1拆分为独立的几个接口（3个）</strong>，类A和类C分别与他们他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p><h4 id="2-4-2-上图违反接口隔离原则代码实例-pdf"><a href="#2-4-2-上图违反接口隔离原则代码实例-pdf" class="headerlink" title="2.4.2 上图违反接口隔离原则代码实例(pdf)"></a>2.4.2 上图违反接口隔离原则代码实例(pdf)</h4><h4 id="2-4-3-使用接口隔离原则改进"><a href="#2-4-3-使用接口隔离原则改进" class="headerlink" title="2.4.3 使用接口隔离原则改进"></a>2.4.3 使用接口隔离原则改进</h4><p>将接口Interface1拆分为独立的三个接口。</p><p><img src="https://img-blog.csdnimg.cn/7f5c1c942bfa44e4bad43b1a4e78691b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="2-4-4-接口隔离原则改进后的代码实例-pdf"><a href="#2-4-4-接口隔离原则改进后的代码实例-pdf" class="headerlink" title="2.4.4 接口隔离原则改进后的代码实例(pdf)"></a>2.4.4 接口隔离原则改进后的代码实例(pdf)</h4><h3 id="2-5-依赖倒转原则"><a href="#2-5-依赖倒转原则" class="headerlink" title="2.5 依赖倒转原则"></a>2.5 依赖倒转原则</h3><h4 id="2-5-1-基本介绍："><a href="#2-5-1-基本介绍：" class="headerlink" title="2.5.1 基本介绍："></a>2.5.1 基本介绍：</h4><p>依赖倒转的中心思想是<strong>面向接口编程</strong>。</p><p><strong>抽象不应该依赖细节，细节应该依赖抽象。</strong></p><p>依赖倒转原则基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类。</p><p>使用<strong>接口或抽象类</strong>的目的制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p><h4 id="2-5-2-依赖倒转原则代码实例-pdf"><a href="#2-5-2-依赖倒转原则代码实例-pdf" class="headerlink" title="2.5.2 依赖倒转原则代码实例(pdf)"></a>2.5.2 依赖倒转原则代码实例(pdf)</h4><h4 id="2-5-3-依赖关系传递的三种方式"><a href="#2-5-3-依赖关系传递的三种方式" class="headerlink" title="2.5.3 依赖关系传递的三种方式"></a>2.5.3 依赖关系传递的三种方式</h4><ol><li>接口传递</li><li>构造方法传递</li><li>setter方式传递</li></ol><h4 id="2-5-4-依赖倒转原则的注意事项和细节"><a href="#2-5-4-依赖倒转原则的注意事项和细节" class="headerlink" title="2.5.4 依赖倒转原则的注意事项和细节"></a>2.5.4 依赖倒转原则的注意事项和细节</h4><ol><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。</li><li>变量的<strong>声明类型尽量使抽象类或接口</strong>，这样我们的变量引用和实际对象间，就存在一个<strong>缓冲层</strong>，利于程序扩展和优化。</li><li>继承时遵循<strong>里氏替换</strong>原则。</li></ol><h3 id="2-6-里氏替换原则"><a href="#2-6-里氏替换原则" class="headerlink" title="2.6 里氏替换原则"></a>2.6 里氏替换原则</h3><h4 id="2-6-1-OO中的继承说明："><a href="#2-6-1-OO中的继承说明：" class="headerlink" title="2.6.1 OO中的继承说明："></a>2.6.1 OO中的继承说明：</h4><ol><li>继承中包含这样一层含义，父类中凡是已经实现好的方法，实际上时在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li>继承有利有弊，使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个B继承了A，C也继承了A，当改动A类时，所有涉及到子类的功能都有可能产生故障</li><li>所以说正确的使用继承要遵守里氏替换原则。</li></ol><h4 id="2-6-2-基本介绍："><a href="#2-6-2-基本介绍：" class="headerlink" title="2.6.2 基本介绍："></a>2.6.2 基本介绍：</h4><p><strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</p><p>在使用继承时，遵循里氏替换原则，<strong>在子类中尽量不要重写父类的方法</strong>。</p><p>里氏替换原则告诉我们，继承实际上让两个类的耦合性增强了，适当情况下，可以<strong>通过聚合，组合，依赖来解决问题</strong>。</p><h4 id="2-6-3-由于重写父类方法导致出现问题的解决方法："><a href="#2-6-3-由于重写父类方法导致出现问题的解决方法：" class="headerlink" title="2.6.3 由于重写父类方法导致出现问题的解决方法："></a>2.6.3 由于重写父类方法导致出现问题的解决方法：</h4><p>通常的做法是，原来的父类和子类都继承一个更通俗的积累，这样可以将原有的继承关系去掉，采用依赖，聚合，组合等关系替代。</p><p><img src="https://img-blog.csdnimg.cn/73fb52778fe14f4dbfde2775cd5a0ee5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Liskov</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span>+a.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<br>        System.out.println(<span class="hljs-string">&quot;1-8=&quot;</span>+a.func1(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));<br>        <br>        System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);<br>    <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>       System.out.println(<span class="hljs-string">&quot;11+3=&quot;</span>+b.func1(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<br>        System.out.println(<span class="hljs-string">&quot;11+3=&quot;</span>+b.func2(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<br>        <br>        <span class="hljs-comment">//使用组合仍然可以使用A类相关方法</span><br>        System.out.println(<span class="hljs-string">&quot;11-3=&quot;</span>+a.func3(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建一个更基础的基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>&#123;<br>        <span class="hljs-keyword">return</span> num1-num2;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//⭐重点理解组合</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span>&#123;<br>    <span class="hljs-comment">//如果B需要使用A类的方法，使用组合关系</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> func1(a, b)+<span class="hljs-number">9</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func3</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a.func1(a, b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-开闭原则"><a href="#2-7-开闭原则" class="headerlink" title="2.7 开闭原则"></a>2.7 开闭原则</h3><h4 id="2-7-1-基本介绍"><a href="#2-7-1-基本介绍" class="headerlink" title="2.7.1 基本介绍"></a>2.7.1 基本介绍</h4><ol><li>开闭原则是编程中<strong>最基础，最重要</strong>的设计原则</li><li>一个软件实体如类，模块和函数应该**对扩展开放(对提供方)，对修改关闭(对使用方)**。用抽象构建框架，用实现扩展细节。</li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li></ol><h4 id="2-7-2-未改进前"><a href="#2-7-2-未改进前" class="headerlink" title="2.7.2 未改进前"></a>2.7.2 未改进前</h4><p><img src="https://img-blog.csdnimg.cn/b31791baeafd4e22a772ebdd8b5876ad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="2-7-3-对未改进前进行分析"><a href="#2-7-3-对未改进前进行分析" class="headerlink" title="2.7.3 对未改进前进行分析"></a>2.7.3 对未改进前进行分析</h4><ol><li>这样子设计代码违反了设计模式的开闭原则，即对扩展开放，对修改关闭。</li><li>我们给类增加新功能的时候，需要尽量不修改代码，或者尽可能少修改代码。</li></ol><h4 id="2-7-4-改进"><a href="#2-7-4-改进" class="headerlink" title="2.7.4 改进"></a>2.7.4 改进</h4><p>思路：将Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可，这样有新的类加进来的时候，只需要让新的类继承Shape，并实现draw方法即可，使用方的代码就不需要修改，满足了开闭原则。</p><p><img src="https://img-blog.csdnimg.cn/c8d148b17252496cacc96283d0de0ddf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="2-8-迪米特法则"><a href="#2-8-迪米特法则" class="headerlink" title="2.8 迪米特法则"></a>2.8 迪米特法则</h3><h4 id="2-8-1-基本介绍"><a href="#2-8-1-基本介绍" class="headerlink" title="2.8.1 基本介绍"></a>2.8.1 基本介绍</h4><ol><li>一个对象应该与其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则有叫做最少知道原则，一个类对自己依赖的类知道的越少越好。</li><li>更简单的说：就是<strong>只与直接的朋友通信，自己做自己的事情</strong></li><li>直接的朋友：每个对象与其他对象都会有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象是朋友关系。耦合的方式有很多，依赖，关联，组合，聚合等…其中，我们称<strong>成员变量，方法参数，方法返回值中的类为直接朋友</strong>，而出现在局部变量中的类不是直接的朋友，也就是说按照迪米特法则，<strong>陌生的类最好不要以局部变量的形式出现在类的内部</strong>。</li></ol><h4 id="2-8-2-迪米特法则注意事项和细节"><a href="#2-8-2-迪米特法则注意事项和细节" class="headerlink" title="2.8.2 迪米特法则注意事项和细节"></a>2.8.2 迪米特法则注意事项和细节</h4><ol><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求<strong>降低</strong>类间(对象间)耦合关系，<strong>并不是要求完全没有依赖关系</strong>。</li></ol><h3 id="2-9-合成复用原则"><a href="#2-9-合成复用原则" class="headerlink" title="2.9 合成复用原则"></a>2.9 合成复用原则</h3><h4 id="2-9-1-基本介绍"><a href="#2-9-1-基本介绍" class="headerlink" title="2.9.1 基本介绍"></a>2.9.1 基本介绍</h4><p>原则是尽量使用合成&#x2F;聚合的方式，而不是使用继承，用以下三种方式替代可以解耦（<strong>方法参数，成员变量set注入，成员变量直接new</strong>）</p><p><img src="https://img-blog.csdnimg.cn/b43eb8279dda4c87adab4977c75b3428.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGD6IqxZXI=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="2-10-设计原则核心思想"><a href="#2-10-设计原则核心思想" class="headerlink" title="2.10 设计原则核心思想"></a>2.10 设计原则核心思想</h3><ol><li>找出应用中可能需要变化之处，把它们<strong>独立出来</strong>，不要和哪些不需要变化的代码混在一起。</li><li><strong>针对接口编程</strong>，而不是针对实现编程</li><li>为了交互对象之间的<strong>松耦合</strong>设计而努力。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java设计模式（第一章）</title>
    <link href="/2022/01/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/"/>
    <url>/2022/01/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="第一章：内容介绍"><a href="#第一章：内容介绍" class="headerlink" title="第一章：内容介绍"></a>第一章：内容介绍</h2><h3 id="设计模式的重要性："><a href="#设计模式的重要性：" class="headerlink" title="设计模式的重要性："></a>设计模式的重要性：</h3><ol><li>软件工程中，<strong>设计模式</strong>是软件设计中普遍存在的各种问题所提出的<strong>解决方案</strong>。</li><li>拿实际工作经历来说，当一个项目开发完后，如果<strong>客户提出增加新的功能</strong>，怎么办？（可扩展性，使用设计模式，软件具有很好的扩展性）</li><li>如果项目开发完后，程序员离职，你接手维护该项目怎么办？（<strong>维护性</strong>[可读性、规范性]）</li><li>面试会问你<strong>在实际项目中使用过什么设计模式，怎么使用的，解决了什么问题</strong>。</li><li>设计模式在软件中哪里？面向对象(oo)&#x3D;&gt;功能模块[设计模式+算法(数据结构)]</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oracle的归档模式和非归档模式的切换</title>
    <link href="/2021/06/13/Oracle%E7%9A%84%E5%BD%92%E6%A1%A3%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%9E%E5%BD%92%E6%A1%A3%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%87%E6%8D%A2/"/>
    <url>/2021/06/13/Oracle%E7%9A%84%E5%BD%92%E6%A1%A3%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%9E%E5%BD%92%E6%A1%A3%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="Oracle的归档模式和非归档模式的切换"><a href="#Oracle的归档模式和非归档模式的切换" class="headerlink" title="Oracle的归档模式和非归档模式的切换"></a>Oracle的归档模式和非归档模式的切换</h2><h4 id="非归档模式-gt-归档模式"><a href="#非归档模式-gt-归档模式" class="headerlink" title="非归档模式-&gt;归档模式"></a>非归档模式-&gt;归档模式</h4><p><strong>第一步</strong>：使用archive log list查看当前归档状态<br><img src="https://img-blog.csdnimg.cn/20210613184628555.png"><br><strong>第二步</strong>：关闭数据库<br><img src="https://img-blog.csdnimg.cn/20210613184736859.png"><br><strong>第三步</strong>：将数据库开启到mount状态<br><img src="https://img-blog.csdnimg.cn/2021061318485117.png"><br><strong>第四步</strong>：改变归档状态<br><img src="https://img-blog.csdnimg.cn/20210613184943485.png"><br><strong>第五步</strong>：改变成功，将数据库恢复到open状态后即可以进行一系列操作了。<br><img src="https://img-blog.csdnimg.cn/20210613185057950.png"></p><h4 id="归档模式-gt-非归档模式"><a href="#归档模式-gt-非归档模式" class="headerlink" title="归档模式-&gt;非归档模式"></a>归档模式-&gt;非归档模式</h4><p>与非归档模式转换成归档模式的方法基本一致，关闭数据库，将数据库开启到mount状态,<br>改变归档状态为非归档模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> database noarchivelog;<br></code></pre></td></tr></table></figure><p>将数据库恢复到open状态。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2021/04/27/Git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/27/Git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h2><h4 id="工作区、暂存区、本地库"><a href="#工作区、暂存区、本地库" class="headerlink" title="工作区、暂存区、本地库"></a>工作区、暂存区、本地库</h4><p><img src="https://img-blog.csdnimg.cn/20210427182310167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>Git的常用命令<br><img src="https://img-blog.csdnimg.cn/20210427182356194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>在gitbash中找到自己的工作区后使用git init命令可以初始化工作区，产生一个.git的隐藏文件夹</p><p>在gitbash中输入以下命令，在工作区里新建一个hello.txt文件</p><blockquote><p>vim hello.txt</p></blockquote><p>按i写入信息，写完后按Esc然后:wq保存并退出，然后查看状态，使用git status命令发现是红色的，意思就是还在工作区，还未加入到暂存区中</p><blockquote><p>git status</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210427183029770.png"></p><p>使用git add hello.txt命令加入到暂存区中</p><blockquote><p>git add hello.txt</p></blockquote><p>再次查看状态已经是绿色了，说明文件已经添加进暂存区中<br><img src="https://img-blog.csdnimg.cn/20210427183128306.png"><br>从暂存区删除(工作区文件仍然在)可以使用以下命令</p><blockquote><p>git rm –cached hello.txt</p></blockquote><p>然后状态又会变成红色了</p><p>然后就是提交到本地库的命令</p><blockquote><p>git commit -m “first commit” hello.txt</p></blockquote><p>这里-m后的字符串是自己加的注释，提交完后查看状态如图所示<br><img src="https://img-blog.csdnimg.cn/20210427183512353.png"><br>使用git reflog命令可以查看提交的版本(类似于历史记录)<br>更为详细的信息可以使用git log命令</p><p>如果提交到本地库后修改了文件hello.txt，需要再次执行git add命令以及git commit命令提交到本地库进行记录，下图为修改过hello.txt后查看状态的截图<br><img src="https://img-blog.csdnimg.cn/2021042718380053.png"><br>使用cat hello.txt命令可以查看当前目录hello.txt文件中的内容</p><blockquote><p>cat hello.txt</p></blockquote><p>利用git reset –hard 版本号 命令可以进行版本穿梭</p><blockquote><p>git reset –hard 5770506</p></blockquote><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p><img src="https://img-blog.csdnimg.cn/20210427184301726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>使用git branch -v命令可以查看当前所在分支，以及当前分支的版本</p><blockquote><p>git branch -v</p></blockquote><p>使用git branch hot-fix命令可以新建一个叫做hot-fix的分支</p><blockquote><p>git branch hot-fix</p></blockquote><p>使用git checkout 分支名命令可以切换当前所在的分支</p><blockquote><p>git checkout hot-fix</p></blockquote><p>然后在hot-fix分支下修改hello.txt文件之后，查看状态发现也是没有加到暂存区中的，所以也是需要add和commit的。</p><p>使用git merge 新分支可以将新分支合并到当前所在分支上，正常合并(在master分支下输入以下命令)</p><blockquote><p>git merge hot-fix</p></blockquote><p>当发生合并冲突时(既修改了master分支又修改了hot-fix分支使用上面的git merge命令就会出问题)就需要手动合并了。<br><img src="https://img-blog.csdnimg.cn/2021042718510522.png"><br>然后当前分支会显示成这样<br><img src="https://img-blog.csdnimg.cn/20210427185126140.png"><br>然后查看状态<br><img src="https://img-blog.csdnimg.cn/20210427185211758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>会发现报两个hello.txt都被修改的错误，所以这个时候需要手动修改文件<br>这个时候需要用vim hello.txt命令打开文件</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs asciidoc">共同的内容<br>\&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><span class="hljs-section">主分支的内容</span><br><span class="hljs-section">=======</span><br>合并分支的内容<br>\&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix<br></code></pre></td></tr></table></figure><p>这个时候手动修改就好了(将多余的内容删除然后:wq保存)。</p><h4 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h4><h5 id="组内协作"><a href="#组内协作" class="headerlink" title="组内协作"></a>组内协作</h5><p><img src="https://img-blog.csdnimg.cn/20210427185547110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210427190058280.png"><br>在github上新建一个repository然后给远程地址取个别名</p><blockquote><p>git remote add git-demo <a href="https://github.com/xxx/git-demo.git">https://github.com/xxx/git-demo.git</a></p></blockquote><p>本地库的文件pull到远程库，会弹出一个窗口要求绑定GitHub</p><blockquote><p>git push git-demo master</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210427190641884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"></p><p>选择第一个按钮授权即可。<br>然后就可以成功上传到远程库啦！</p><p>如果在GitHub上修改了hello.txt然后可以通过git pull git-demo hello.txt将hello.txt拉取到本地库</p><blockquote><p>git pull git-demo hello.txt</p></blockquote><h5 id="克隆远程库到本地"><a href="#克隆远程库到本地" class="headerlink" title="克隆远程库到本地"></a>克隆远程库到本地</h5><p>使用git clone命令将远程库中的资源克隆到本地库中</p><blockquote><p>git clone <a href="https://github.com/xxx/git-demo.git">https://github.com/xxx/git-demo.git</a></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210427194548461.png"><br>git clone命令主要做的是三件事：1、拉取代码。2、初始化本地仓库。3、创建别名(默认是origin)</p><p>使用git push命令将本地库中的资源上传到远程库中</p><blockquote><p>git push <a href="https://github.com/xxx/git-demo.git">https://github.com/xxx/git-demo.git</a></p></blockquote><p>如果你是a用户，则push到a用户的github上使用该方法可以，如果你是b用户想要push到a用户的github上，则需要a用户授权(a用户在github上拉b用户进入小组，即可获取权限)，这就是团队内部协作</p><h4 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h4><p><img src="https://img-blog.csdnimg.cn/20210427185839535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>如果是跨团队合作，例如a和b是一个团队的，c是另一个团队的，这个时候c需要帮助ab团队，则需要在github上将需要的代码fork到自己的远程库中，然后进行修改，但是这个修改只是在自己的远程库的操作，要改动ab团队的库则需要使用pull request功能<br><img src="https://img-blog.csdnimg.cn/20210427200714204.png"><br><img src="https://img-blog.csdnimg.cn/20210427200742500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL8.0局域网共享</title>
    <link href="/2021/04/19/MySQL8.0%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB/"/>
    <url>/2021/04/19/MySQL8.0%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>第一步</strong>：新建一个用户</p><p>创建一个新用户LTH，如果只允许从本机登陆，则在host处填’localhost’，如果允许从远程登陆，则填’%’，局域网内所有主机都能访问，也可以指定主机如：’192.168.1.1’，后面的是设置的密码。</p><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;user_name&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;password&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>样例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;LTH&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;LTH&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;LTH&#x27;</span>@<span class="hljs-string">&#x27;192.168.1.1&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>第二步</strong>：为用户赋予权限<br>这里也是可以选择权限和数据库和表<br>前面的* 代表所有的数据库，也可指定数据库,后面的*代表表,也可指定表,例如：testDatabase.testTable</p><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;user_name&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br></code></pre></td></tr></table></figure><p><strong>样例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;LTH&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br></code></pre></td></tr></table></figure><p>到了这里可以使用查看USER表的SQL语句查询看用户是否添加成功，权限是否添加成功。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE mysql;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210419012724986.png"><br>这里可以看到LTH用户已经新建完成了，且赋予了所有的权限。</p><p><strong>第三步</strong>:设置安全防火墙<br>打开Windows安全中心，点击防火墙和网络保护<br><img src="https://img-blog.csdnimg.cn/20210419013025627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>然后点击高级设置<br><img src="https://img-blog.csdnimg.cn/20210419013229600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>点击入站规则<br><img src="https://img-blog.csdnimg.cn/20210419013426814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>新建规则，选中端口<br><img src="https://img-blog.csdnimg.cn/20210419013540597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>在特定本地端口栏中输入3306，然后允许连接下一步，何时应用该规则时全选然后确定即可。<br><img src="https://img-blog.csdnimg.cn/20210419013624986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210419013738336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>最后名称自己取一个名字（我这里取的是testMySQL），点击完成，即可在同一局域网下数据库实现互联了。</p><p><img src="https://img-blog.csdnimg.cn/20210419013749512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>可以在入站规则中找到刚刚自己设置的入站规则。<br><img src="https://img-blog.csdnimg.cn/fc69fa70a16d4213a4b6bf991e1d460f.png"></p><p><strong>最后，在同一局域网用不同的电脑访问本机，大功告成！</strong><br><img src="https://img-blog.csdnimg.cn/20210419014614575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步代码块处理实现Runnable线程安全问题</title>
    <link href="/2021/04/17/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0Runnable%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/17/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0Runnable%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> safe_sell_tickets;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *    如何解决线程安全问题？在java中通过同步机制来解决</span><br><span class="hljs-comment"> *     方法一：同步代码块</span><br><span class="hljs-comment"> *     synchronized(同步监视器)&#123;  --&gt;不能包含代码多了，也不要包含代码少了</span><br><span class="hljs-comment"> *          //需要被同步的代码</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> *     说明：①操作共享数据的代码，即为需要被同步的代码</span><br><span class="hljs-comment"> *          ②共享数据：多个线程共同操作的变量。比如：ticket就是共享数据</span><br><span class="hljs-comment"> *          ③同步监视器，俗称：锁。任何一个类的对象都可以充当锁。</span><br><span class="hljs-comment"> *              要求：多个线程必须共用同一个锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *          补充：在实现Runnable接口创建多线程的方式中，我们可以考虑用this来充当同步监视器</span><br><span class="hljs-comment"> *     方法二：同步方法</span><br><span class="hljs-comment"> *        如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    同步的方式，解决了线程的安全问题</span><br><span class="hljs-comment"> *    操作代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/17 - 13:01</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">tickets</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//对象可以是任意的，写this也可以，因为main方法中只new了一个My_Thread3的对象，是唯一的</span><br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>            <span class="hljs-keyword">while</span>(tickets &gt; <span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName() + tickets);<br>                tickets--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread3</span> <span class="hljs-variable">m3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">w1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(m3);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">w2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(m3);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">w3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(m3);<br><br>        w1.setName(<span class="hljs-string">&quot;窗口1：&quot;</span>);<br>        w2.setName(<span class="hljs-string">&quot;窗口2：&quot;</span>);<br>        w3.setName(<span class="hljs-string">&quot;窗口3：&quot;</span>);<br><br>        w1.start();<br>        w2.start();<br>        w3.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的生命周期</title>
    <link href="/2021/04/17/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2021/04/17/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>JDK中用Thread.State类定义了线程的几种状态：<br>1、新建：一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态<br>2、就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没有分配到CPU资源<br>3、运行：当就绪的线程被调度并获得CPU资源时，便进入了运行状态，run()方法定义了线程的操作和功能<br>4、阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态<br>5、死亡：线程完成了它的全部工作或线程被提前强制性的中止或出现异常导致结束。</p><p><img src="https://img-blog.csdnimg.cn/20210417115254584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过实现Runnable接口来创建多线程</title>
    <link href="/2021/04/17/%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/04/17/%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> create_thread;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现Runnable接口方式创建多线程</span><br><span class="hljs-comment"> * 1.创建一个类去实现Runnable接口</span><br><span class="hljs-comment"> * 2.实现类去实现Runnable接口中的抽象方法run()</span><br><span class="hljs-comment"> * 3.创建此实现类的对象</span><br><span class="hljs-comment"> * 4.将此对象作为参数传递到Thread类的构造器中，创建Thread类对象</span><br><span class="hljs-comment"> * 5.通过Thread类的对象调用start()</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/16 - 16:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i += <span class="hljs-number">2</span>) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread2</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread2</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(m1);<br>        t1.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210416164004152.png"><br>此处：传参处为多态。实现接口的类对象m1作为参数传给Runnable接口类型的target变量。然后一直ctrl键点this发现源码中重复调用重载的构造器，最后为<code>this.target=target;</code><br><img src="https://img-blog.csdnimg.cn/20210417104318747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>所以说这里t1.start()最后执行的还是传入构造器中m1的run()方法。如果想要再启动一个线程，而新线程与MyThread2是一样的，则无需新建MyThread2类的对象，只需将m1传入新的Thread构造器创建一个新的Thread类对象(t2)即可。<code>Thread t2 = new Thread(m1);</code></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thread类中的常用方法和属性</title>
    <link href="/2021/04/16/Thread%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/04/16/Thread%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p><strong>Thread中的常用方法</strong></p><p>1.start(): 启动当前线程： 调用当前线程的run()<br>2.run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中<br>3.currentThread(): 静态方法，返回执行当前代码的线程<br>4.getName(): 获取当前线程的名字<br>5.setName(): 设置当前线程的名字<br>6.yield(): 释放当前CPU的执行权<br>7.join(): 在线程a中调用线程b的join(),此时线程a就进入阻塞状态，            直到线程b完全执行完以后，线程a才结束阻塞状态<br>8.stop(): 已过时。当执行此方法时，强制结束当前线程。<br>9.sleep(long millitime):让当前线程”睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。<br>10.isAlive(): 判断当前线程是否存活</p><p><strong>线程的优先级：</strong><br>MAX_PRIORITY: 10<br>MIN_PRIORITY: 1<br>NORM_PRIORITY: 5 –&gt;默认优先级</p><p>获取线程的优先级和设置线程的优先级：<br> getPriority();获取线程的优先级<br> setPriority(int p):设置线程的优先级</p><p> 说明：高优先级的线程要抢占低优先级线程的cpu执行权。但是只能从概率上来讲，高优先级的线程高概率的情况下被执行。并不意味着当高优先级的线程执行完以后，低优先级的线程才执行。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流中的对象流ObjectInputStream和ObjectOutputStream</title>
    <link href="/2021/04/06/IO%E6%B5%81%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B5%81ObjectInputStream%E5%92%8CObjectOutputStream/"/>
    <url>/2021/04/06/IO%E6%B5%81%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B5%81ObjectInputStream%E5%92%8CObjectOutputStream/</url>
    
    <content type="html"><![CDATA[<p>在对String的序列化时是可以成功的，因为String类实现了Serializable接口。<br><img src="https://img-blog.csdnimg.cn/20210406184613382.png"><br>Serializable是一个标记接口，里面没有需要重写的方法<br><img src="https://img-blog.csdnimg.cn/20210406184638763.png"></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对象流的使用：</span><br><span class="hljs-comment"> * 1、ObjectInputStream 和 ObjectOutputStream</span><br><span class="hljs-comment"> * 2、作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象还原回来</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/6 - 18:26</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectInputStreamOutputStream</span> &#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        序列化过程：将内存中的Java对象保存到磁盘中或通过网络传输出去</span><br><span class="hljs-comment">        使用ObjectOutputStream实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testObjectOutputStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.造流</span><br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;object.dat&quot;</span>));<br>            <span class="hljs-comment">//2.操作</span><br>            oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;阿巴阿巴123&quot;</span>));<br>            oos.flush();<span class="hljs-comment">//刷新操作</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (oos != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//3.资源的关闭</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    oos.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        反序列化过程：将磁盘文件中的对象还原为内存中的一个Java对象</span><br><span class="hljs-comment">        使用ObjectInputStream实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testObjectInputStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;object.dat&quot;</span>));<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) obj;<br>            System.out.println(str);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (ois != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    ois.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210406184703962.png"><br>在对自定义类序列化时，必须让自定义类实现Serializable接口且提供一个全局常量：serialVersionUID，否则会报错。<br>在Person类未改变的情况下不加serialVersionUID也是可以的，但是如果序列化后改变了Person类(如加了新的属性等…)反序列化时就会出错。所以总的来说就是需要让自定义类实现Serializable接口和提供全局常量：serialVersionUID。还有一种情况是自定义类中的属性的类型也是自定义类，那这个时候自定义类中的属性的类型的自定义类也要实现序列化，否则依然会导致Person的序列化失败。<br>比如新建一个Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/6 - 18:39</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>再利用上面的测试方法结果是报错的。<br><img src="https://img-blog.csdnimg.cn/2021040618501717.png"><br>所以需要将Person序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Person需要满足如下的要求，方可序列化</span><br><span class="hljs-comment"> * 1、需要实现接口：Serializable</span><br><span class="hljs-comment"> * 2、需要当前类提供一个全局常量：serialVersionUID</span><br><span class="hljs-comment"> * 3、除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性</span><br><span class="hljs-comment"> *   也必须是可序列化的。(默认情况下，基本数据类型可序列化)</span><br><span class="hljs-comment"> * 4、序列化机制：</span><br><span class="hljs-comment"> *  对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，</span><br><span class="hljs-comment"> *  或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</span><br><span class="hljs-comment"> * 注意：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/6 - 18:39</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//这里的serialVersionUID的值可以随便提供。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1232412412451L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对象流的使用：</span><br><span class="hljs-comment"> * 1、ObjectInputStream 和 ObjectOutputStream</span><br><span class="hljs-comment"> * 2、作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象还原回来</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/6 - 18:26</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectInputStreamOutputStream</span> &#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        序列化过程：将内存中的Java对象保存到磁盘中或通过网络传输出去</span><br><span class="hljs-comment">        使用ObjectOutputStream实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testObjectOutputStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.造流</span><br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;object.dat&quot;</span>));<br>            <span class="hljs-comment">//2.操作</span><br>            oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;阿巴阿巴123&quot;</span>));<br>            oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">123</span>));<br>            oos.flush();<span class="hljs-comment">//刷新操作</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (oos != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//3.资源的关闭</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    oos.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        反序列化过程：将磁盘文件中的对象还原为内存中的一个Java对象</span><br><span class="hljs-comment">        使用ObjectInputStream实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testObjectInputStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;object.dat&quot;</span>));<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) obj;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) ois.readObject();<br>            System.out.println(str);<br>            System.out.println(p);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (ois != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    ois.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流中的转换流InputStreamReader和OutputStreamWriter</title>
    <link href="/2021/04/04/IO%E6%B5%81%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%B5%81InputStreamReader%E5%92%8COutputStreamWriter/"/>
    <url>/2021/04/04/IO%E6%B5%81%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%B5%81InputStreamReader%E5%92%8COutputStreamWriter/</url>
    
    <content type="html"><![CDATA[<h2 id="通过转换流可以实现字节流和字符流之间的转换"><a href="#通过转换流可以实现字节流和字符流之间的转换" class="headerlink" title="通过转换流可以实现字节流和字符流之间的转换"></a>通过转换流可以实现字节流和字符流之间的转换</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理流之二：转换流的使用</span><br><span class="hljs-comment"> * 1.转换流：属于字符流</span><br><span class="hljs-comment"> *  InputStreamReader: 将一个字节的输入流转换为字符的输入流，相当于解码</span><br><span class="hljs-comment"> *  OutputStreamWriter: 将一个字符的输出流转换为字节的输出流，相当于编码</span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * 2.作用: 提供字节流与字符流之间的转换</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 3.解码: 字节、字节数组    ----&gt;  字符数组、字符串</span><br><span class="hljs-comment"> *   编码: 字符数组、字符串  ----&gt;  字节、字节数组</span><br><span class="hljs-comment"> *   </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/4 - 10:34</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReader_OutputStreamWriter</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.造文件、造流</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>            <span class="hljs-type">File</span> <span class="hljs-variable">file2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello_gbk.txt&quot;</span>);<br><br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file1);<br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file2);<br><br>            <span class="hljs-comment">//以utf-8的格式读入，以gbk的格式写出，会显示乱码</span><br>            isr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>            osw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(fos, <span class="hljs-string">&quot;gbk&quot;</span>);<br><br>            <span class="hljs-comment">//2.读写过程</span><br>            <span class="hljs-type">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">20</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = isr.read(cbuf)) != -<span class="hljs-number">1</span>) &#123;<br>                osw.write(cbuf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//3.关闭资源</span><br>            <span class="hljs-keyword">if</span> (isr != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    isr.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (osw != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    osw.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流中的BufferedInputStream和BufferedOutputStream</title>
    <link href="/2021/04/04/IO%E6%B5%81%E4%B8%AD%E7%9A%84BufferedInputStream%E5%92%8CBufferedOutputStream/"/>
    <url>/2021/04/04/IO%E6%B5%81%E4%B8%AD%E7%9A%84BufferedInputStream%E5%92%8CBufferedOutputStream/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理流之一： 缓冲流的使用</span><br><span class="hljs-comment"> * 1.缓冲流</span><br><span class="hljs-comment"> * BufferedInputStream</span><br><span class="hljs-comment"> * BufferedOutputStream</span><br><span class="hljs-comment"> * BufferedReader</span><br><span class="hljs-comment"> * BufferedWriter</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 2.作用：提供流的读取，写入的速度</span><br><span class="hljs-comment"> * 提高读写速度的原因：内部提供了一个缓冲区8192</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 3.处理流，就是”套接“在已有流的基础上。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/4 - 9:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BufferedStreamTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.造文件</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test图片.jpg&quot;</span>);<br>            <span class="hljs-type">File</span> <span class="hljs-variable">destFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test3图片.jpg&quot;</span>);<br><br>            <span class="hljs-comment">//2.造流</span><br>            <span class="hljs-comment">//2.1 造节点流</span><br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(srcFile);<br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(destFile);<br>            <span class="hljs-comment">//2.2 造缓冲流</span><br>            bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>            bos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br><br>            <span class="hljs-comment">//3.复制的细节：读取、写入</span><br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = bis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>                bos.write(buffer, <span class="hljs-number">0</span>, len);<br>                <span class="hljs-comment">//bos.flush(); //刷新缓冲区</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//4.资源关闭</span><br>            <span class="hljs-comment">//说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span><br>            <span class="hljs-keyword">if</span> (bos != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    bos.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bis != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    bis.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流中的BufferedInputStream和BufferedOutputStream</title>
    <link href="/2021/04/04/IO%E6%B5%81%E4%B8%AD%E7%9A%84FileInputStream%E5%92%8CFileOutputStream/"/>
    <url>/2021/04/04/IO%E6%B5%81%E4%B8%AD%E7%9A%84FileInputStream%E5%92%8CFileOutputStream/</url>
    
    <content type="html"><![CDATA[<h2 id="利用IO流中的FileInputStream和FileOutputStream来实现读写操作"><a href="#利用IO流中的FileInputStream和FileOutputStream来实现读写操作" class="headerlink" title="利用IO流中的FileInputStream和FileOutputStream来实现读写操作"></a>利用IO流中的FileInputStream和FileOutputStream来实现读写操作</h2><p>FileInputStream和FileOutputStream是字节流，与FileReader和FileWriter不同。它的缓冲数组为byte类型的，可以处理非文本文件和文本文件，但是在处理文本文件的时候不能显示在控制台中(如果文本文件中有中文字符或其他特殊字符的话，因为会受到byte数组大小的影响从而会导致字符被分割开出现乱码)<br><img src="https://img-blog.csdnimg.cn/20210404094302926.png"><br>如果复制这个更改后的hello文件，在控制台输出会出现乱码<br><img src="https://img-blog.csdnimg.cn/20210404094746798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/4 - 9:36</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStreamOutputStream</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFileInputOutputStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">File</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;pic.png&quot;</span>);<br>            <span class="hljs-type">File</span> <span class="hljs-variable">destFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;pic2.png&quot;</span>);<br><br>            fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(srcFile);<br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(destFile);<br><br>            <span class="hljs-comment">//复制的过程</span><br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">5</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = fis.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>                fos.write(buffer, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(fos != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fos.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(fis != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fis.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流中的FileReader和FileWriter</title>
    <link href="/2021/04/04/IO%E6%B5%81%E4%B8%AD%E7%9A%84FileReader%E5%92%8CFileWriter/"/>
    <url>/2021/04/04/IO%E6%B5%81%E4%B8%AD%E7%9A%84FileReader%E5%92%8CFileWriter/</url>
    
    <content type="html"><![CDATA[<h2 id="利用IO流中的FileReader和FileWriter来实现读写操作"><a href="#利用IO流中的FileReader和FileWriter来实现读写操作" class="headerlink" title="利用IO流中的FileReader和FileWriter来实现读写操作"></a>利用IO流中的FileReader和FileWriter来实现读写操作</h2><p>注意：字符流是不能对非文本文件进行复制操作的<br>文本文件：.txt, .java, .c, .cpp<br>非文本文件(.jpg, .mp3, .mp4, .avi, .doc, .ppt…)，使用字节流来处理</p><p>总的来说就是分为四个步骤<br>①造文件<br>②造流<br>③对文件的处理<br>④资源的关闭</p><p>在对文件的处理的时候通过一个char型数组来提高效率。</p><p>Reader抽象类的read方法(源码)<br>只要cbuf中还有数据，read方法就不不停的读入，直到读完返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">char</span> cbuf[])</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> read(cbuf, <span class="hljs-number">0</span>, cbuf.length);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">char</span> cbuf[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><p>通过源码注释可知，返回值为读入字节的个数</p><p>Writer抽象类的write方法(源码)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">char</span> cbuf[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        se.write(cbuf, off, len);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210404084444239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br>通过源码可知write方法通过第二个参数和第三个参数来写入文件中，off为起始索引，len为结束索引。所以在下面的对文件读写的操作代码中写的是fr.wirte(cbuf, 0, len)而不是fr.write(cbuf, 0, cbuf.length)因为cbuf中并不一定全部都是刚刚写入的数据。<br><img src="https://img-blog.csdnimg.cn/20210404083813271.png"></p><p>比如说这个hello文件，如果使用前者方法读出来的是helloworld123，如果使用后者则会读出来helloworld123ld，因为read操作实际上是对cbuf数组的覆盖，而ld仍然在cbuf数组中，所以读出来的时候根据cbuf.length会读出123ld出来。</p><p>至于为什么cbuf数组的大小设置为5，这个取决于文件的大小(因为该例子文件过小所以设置为5)，如果数组大小设置过大则会占用内存空间，如果数组大小设置过小，则会多次读写导致效率低，所以通常是取1024的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/4 - 8:14</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReaderFileWriter</span> &#123;<br><br>    <span class="hljs-comment">//注意：在IDEA中单元测试方法相对路径是当前Module下，main方法的相对路径是当前工程下</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 利用FileReader和FileWriter对文件进行读写操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileReaderFileWriter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//1.造文件</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">destFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello1.txt&quot;</span>);<br><br>        <span class="hljs-comment">//2.造流</span><br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(srcFile);<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(destFile);<br>    <br>        <span class="hljs-comment">//3.数据的读入reader和写出操作writer</span><br>        <span class="hljs-comment">//这里的char型数组可以类似为快递小哥的小车,打包好后再送会提高效率，不然多次读写磁盘会降低效率</span><br>        <span class="hljs-type">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-type">int</span> len;<span class="hljs-comment">//记录每次读入到cbuf数组中的字符的个数</span><br>        <span class="hljs-keyword">while</span>((len = fr.read(cbuf)) != -<span class="hljs-number">1</span>)&#123;<br>            fw.write(cbuf, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        <br>        <span class="hljs-comment">//4.流的关闭</span><br>        fw.close();<br>        fr.close();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 利用FileReader和FileWriter对文件进行读写操作</span><br><span class="hljs-comment">     * 因为涉及到资源的关闭，所以说选择使用try-catch-finally来处理异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileReaderFileWriter1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">File</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>            <span class="hljs-type">File</span> <span class="hljs-variable">destFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello1.txt&quot;</span>);<br>            fr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(srcFile);<br>            fw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(destFile);<br>            <span class="hljs-type">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span>((len = fr.read(cbuf)) != -<span class="hljs-number">1</span>)&#123;<br>                fw.write(cbuf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (fw != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fw.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (fr != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fr.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流</title>
    <link href="/2021/04/03/IO%E6%B5%81/"/>
    <url>/2021/04/03/IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="IO流体系"><a href="#IO流体系" class="headerlink" title="IO流体系"></a>IO流体系</h2><table><thead><tr><th>分类</th><th>字节输入流</th><th>字节输出流</th><th>字符输入流</th><th align="center">字符输出流</th></tr></thead><tbody><tr><td><strong>抽象基类</strong></td><td><strong>InputStream</strong></td><td><strong>OutputStream</strong></td><td><strong>Reader</strong></td><td align="center"><strong>Writer</strong></td></tr><tr><td><strong>访问文件</strong></td><td><strong>FileInputStream</strong></td><td><strong>FileOutputStream</strong></td><td><strong>FileReader</strong></td><td align="center"><strong>FileWriter</strong></td></tr><tr><td>访问数组</td><td>ByteInputStream</td><td>ByteOutputStream</td><td>CharArrayReader</td><td align="center">CharArrayWriter</td></tr><tr><td>访问管道</td><td>PipedInputStream</td><td>PipedOutputStream</td><td>PipedReader</td><td align="center">PipedWriter</td></tr><tr><td>访问字符串</td><td></td><td></td><td>StringReader</td><td align="center">StringWriter</td></tr><tr><td><strong>缓冲流</strong></td><td><strong>BufferedInputStream</strong></td><td><strong>BufferedOutputStream</strong></td><td><strong>BufferedReader</strong></td><td align="center"><strong>BufferedWriter</strong></td></tr><tr><td><strong>转换流</strong></td><td></td><td></td><td><strong>InputStreamReader</strong></td><td align="center"><strong>OutputStreamWriter</strong></td></tr><tr><td><strong>对象流</strong></td><td><strong>ObjectInputStream</strong></td><td><strong>ObjectOutputStream</strong></td><td></td><td align="center"></td></tr><tr><td></td><td>FilterInputStream</td><td>FilterOutputStream</td><td>FilterReader</td><td align="center">FilterWriter</td></tr><tr><td>打印流</td><td></td><td>PrintOutputStream</td><td></td><td align="center">PrintWriter</td></tr><tr><td>推回输入流</td><td>PushbackInputStream</td><td></td><td>PushbackReader</td><td align="center"></td></tr><tr><td>特殊流</td><td>DataInputStream</td><td>DataOutputStream</td><td></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用Python的urllib.request爬取placekitten上的猫</title>
    <link href="/2021/04/01/%E5%88%A9%E7%94%A8Python%E7%9A%84urllib.request%E7%88%AC%E5%8F%96placekitten%E4%B8%8A%E7%9A%84%E7%8C%AB/"/>
    <url>/2021/04/01/%E5%88%A9%E7%94%A8Python%E7%9A%84urllib.request%E7%88%AC%E5%8F%96placekitten%E4%B8%8A%E7%9A%84%E7%8C%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="利用Python的urllib-request爬取placekitten上的猫"><a href="#利用Python的urllib-request爬取placekitten上的猫" class="headerlink" title="利用Python的urllib.request爬取placekitten上的猫"></a>利用Python的urllib.request爬取placekitten上的猫</h1><p><img src="https://img-blog.csdnimg.cn/20210401164607313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210401165417346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzMDI0MQ==,size_16,color_FFFFFF,t_70"></p><h3 id="在这里要注意两点："><a href="#在这里要注意两点：" class="headerlink" title="在这里要注意两点："></a>在这里要注意两点：</h3><p>①在with open的时候记得加转义，否则会报错。<br>②如果是在C盘保存记得用管理员身份打开IDLE，否则没权限。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java连接MySQL数据库(通过配置文件)</title>
    <link href="/2021/01/31/Java%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)/"/>
    <url>/2021/01/31/Java%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)/</url>
    
    <content type="html"><![CDATA[<p><strong>连接的具体步骤：</strong><br>1.读取配置文件中的4个基本信息<br>2.加载驱动<br>3.获取连接<br>4.资源关闭</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> util;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> LTH</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021/1/31 - 15:03</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConnection</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.读取配置文件中的4个基本信息</span><br>            is = ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            props.load(is);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> props.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> props.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> props.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">driverClass</span> <span class="hljs-operator">=</span> props.getProperty(<span class="hljs-string">&quot;driverClass&quot;</span>);<br>            <span class="hljs-comment">//2.加载驱动</span><br>            Class.forName(driverClass);<br><br>            <span class="hljs-comment">//3.获取连接</span><br>            connection = DriverManager.getConnection(url, user, password);<br>            System.out.println(connection);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//4.关闭连接和is的操作</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (is != <span class="hljs-literal">null</span>) &#123;<br>                    is.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>                    connection.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣304题：二维区域和检索</title>
    <link href="/2021/01/29/%E5%8A%9B%E6%89%A3304%E9%A2%98%EF%BC%9A%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/"/>
    <url>/2021/01/29/%E5%8A%9B%E6%89%A3304%E9%A2%98%EF%BC%9A%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为-row1-col1-，右下角为-row2-col2-。"><a href="#给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为-row1-col1-，右下角为-row2-col2-。" class="headerlink" title="给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。"></a>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。</h2><blockquote><p>示例:<br>给定 matrix &#x3D; [<br>  [3, 0, 1, 4, 2],<br>  [5, 6, 3, 2, 1],<br>  [1, 2, 0, 1, 5],<br>  [4, 1, 0, 1, 7],<br>  [1, 0, 3, 0, 5]<br>]<br>sumRegion(2, 1, 4, 3) -&gt; 8<br>sumRegion(1, 1, 2, 2) -&gt; 11<br>sumRegion(1, 2, 2, 4) -&gt; 1</p></blockquote><p><strong>难度：</strong> 中等</p><p><strong>算法思路：</strong> 蛮力求解</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><br>    <span class="hljs-type">int</span>[][] matrix;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-built_in">this</span>.matrix = matrix;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(row1 &lt; <span class="hljs-number">0</span> || row1 &gt;= matrix.length || col1 &lt; <span class="hljs-number">0</span> || col1 &gt;= matrix[<span class="hljs-number">0</span>].length <br>        || row2 &lt; <span class="hljs-number">0</span> || row2 &gt;= matrix.length || col2 &lt; <span class="hljs-number">0</span> || col2 &gt;= matrix[<span class="hljs-number">0</span>].length)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(row1 == row2 &amp;&amp; col1 == col2)&#123;<br>            <span class="hljs-keyword">return</span> matrix[row1][col1];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row1; i &lt;= row2; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> col1; j &lt;= col2; j++) &#123;<br>                sum += matrix[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行用时：<strong>164 ms</strong>, 在所有 Java 提交中击败了<strong>5.14%</strong> 的用户<br>内存消耗：<strong>44.1 MB</strong>, 在所有 Java 提交中击败了<strong>51.90%</strong> 的用户</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
